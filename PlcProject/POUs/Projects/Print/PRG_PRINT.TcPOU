<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.11">
  <POU Name="PRG_PRINT" Id="{ed92b124-5714-4a13-a793-01a465126fd2}" SpecialFunc="None">
    <Declaration><![CDATA[PROGRAM PRG_PRINT
(*************************************************************************************************)
(*  FILENAME:    PRG_PRINT.EXP                                                                   *)
(*  PROJECT:     CALMAR PUPLC                                                                    *)
(*  COPYRIGHT:   All rights reserved (c) Wifag//Polytype, Fribourg/Switzerland (2016)            *)
(*  ENVIRONMENT: TwinCAT PLC                                                                     *)
(*  VERSION:     <version>                                                                       *)
(*************************************************************************************************)
(*  DESCRIPTION:                                                                   <description> *)
(*    Controls the digital print system.                                                         *)
(*    Main functions: start detection, printhead master, print unit, print group, print          *)
(*    controller.                                                                                *)
(*                                                                                </description> *)
(*************************************************************************************************)

VAR_INPUT
  (*EL5101*)
  lIKp_EncPulse                       AT%I* : ARRAY [1..iCPr_NB_PM] OF UDINT;       (*current encoder position*)
  bI_EncoderWcState                   AT%I* : ARRAY [1..iCPr_NB_PM] OF BOOL;        (*EL5101 encoder WcState*)
END_VAR

VAR_OUTPUT
  (*Interface OUT to PRG_INK / PRG_MACHINE*)
  bO_InitOk                                 : BOOL := FALSE;  (*Init Ok*)
  bO_PrintSystemOk                          : BOOL := TRUE;
  bO_TemperatureOk                          : BOOL := TRUE;
  bO_TotalWcState                           : BOOL := FALSE;  (*Monitoring: WcStates from all terminals*)
END_VAR

VAR
  nCtr, nCtr2 : UDINT;
  
  // ADS interface instances & mapping and responsible FBs
  // -------------------------------------------------------------
  FB_PU                                     : ARRAY [1..iCPr_NB_PU] OF FB_PU;               (*PU - Print Unit*)
  sAdsPrintUnit                             : ARRAY [1..iCPr_NB_PU] OF ST_ADS_PU;
  sL_BLK_PU                                 : ARRAY [1..iCPr_NB_PU] OF ST_MAP_BLK;
  sPuSettings                               : ST_PuSettings;                            // FB_PU configuration
  fbPrintModule                             : ARRAY [1..iCPr_NB_PM] OF FB_PrintModule;
  sAdsPrintModule                           : ARRAY [1..iCPr_NB_PM] OF ST_ADS_PM;           (*PM -  Print Module *)
  sL_BLK_PM                                 : ARRAY [1..iCPr_NB_PM] OF ST_MAP_BLK;
//FB_PG                                     : ARRAY [1..iCPr_NB_PG] OF FB_PG;               (*PG -  Print Group *)
  sAdsPrintGroup                            : ARRAY [1..iCPr_NB_PG] OF ST_ADS_PG;
  sL_BLK_PG                                 : ARRAY [1..iCPr_NB_PG] OF ST_MAP_BLK;
  FB_PC                                     : ARRAY [1..iCPr_NB_PC] OF FB_PC;               (*PC - Print Controller*)
  sAdsPrintController                       : ARRAY [1..iCPr_NB_PC] OF ST_ADS_PC;
  sL_BLK_PC                                 : ARRAY [1..iCPr_NB_PC] OF ST_MAP_BLK;
  pFB_PC                                    : POINTER TO ARRAY [1..iCPr_NB_PC] OF POINTER TO FB_PC;
  //pFB_PC                                    : ARRAY [1..iCPr_NB_PC] OF POINTER TO FB_PC;    (* pointer array to PCs*)
  FB_PH                                     : ARRAY [1..iCPr_NB_PH] OF FB_PH;           (*PH - Print Head*)
  sAdsPrintHead                             : ARRAY [1..iCPr_NB_PH] OF ST_ADS_PH;
  sL_BLK_PH                                 : ARRAY [1..iCPr_NB_PH] OF ST_MAP_BLK;
  sAdsSheetAlignment                        : ARRAY [1..iCPr_NB_PU] OF ST_ADS_DVTSHEETALIGNMENT;          (*SA - Sheet alignement*)
  sL_BLK_SA                                 : ARRAY [1..iCPr_NB_PU] OF ST_MAP_BLK;
  sAdsSubstrate                             : ARRAY [1..iCPr_NB_SUBSTRATE_DEVICES] OF ST_ADS_SUBSTRATE;   (*SUB - Substrate*)
  sL_BLK_SUB                                : ARRAY [1..iCPr_NB_SUBSTRATE_DEVICES] OF ST_MAP_BLK;
  // -------------------------------------------------------------

  // -------------------------------------------------------------
  // Configuration
  sC_Ads_Info                               : ST_ADS_INFO;      // PRG information for ADS block manager
  sMappingInfo                              : T_MapInfo;        // Block mapping configuration
  ISystemBase                               : I_SystemBase;     // reference to system base
  pModuleDef                                : POINTER TO FB_ModuleDef;    // Module definition in system
  sC_Config_P                               : ST_CONFIG_P;      // PRG configuration  

  // Module
  sModuleMachineState : ARRAY[1..iCPr_NB_PM] OF ST_ModuleMachineInterface;
  bMasterTrigger : BOOL;
  fMasterSpeed : LREAL;
  nMasterPosition : DINT;
  nYShift_center                            : UDINT;            // Y-Shift for centering ph in RAM

  
  fBCTManagerMain                           : FB_CTManagerDefGrid;
  fbPm                                      : FB_ProdManager_DMAX;
  fbHardwarePool                            : FB_HardwarePool;
  fbWorkerVerify                            : FB_WorkerDefGrid_Verify;
  fbWorkerDelete                            : FB_WorkerDefGrid_Delete;
  
  
  // PU
  fb_RTrigStopRequestVarnishChange          : R_TRIG;
  
  
  (* --- Maintainance variables ---*)
  fbOd                                      : FB_OD;        // CoE object dictionary
  (* - file download - *)
  (* -- fw/hw upgrade -- *)
  //fb_fwhw_update                            : FB_CALMAR_UPDATE;
	(* -- hib remote update -- *)
	//fb_pc_hib_rupd                            : ARRAY[1..iCPr_NB_PC] OF FB_PC_HIB_RUPD;(*HIB remote update channels*)
  //fb_hib_rup                                : FB_HIB_UPDATE;                         (*HIB remote updater*)
  (* -- stiching mask manager -- *)
  fb_fdl_mask                               : FB_FILE_DOWNLOAD;                      (*Mask file downloader*)
  (** -- waveform manager -- *)
  fb_fdl_waveform                           : FB_FILE_DOWNLOAD;                      (*waveform file downloader*)
  bWaveformDownloadErr                      : BOOL;                                  (*a waveform douwnload exitst (needed in RIGEN5 only)*)
  tOn_waveform                              : ARRAY[1..iCPr_NB_PC] OF TON;
  bL_waveform_request                       : ARRAY[1..iCPr_NB_PC] OF BOOL;
  lL_PhActStoragetankAssignmentIndex        : ARRAY[1..iCPr_NB_PH] OF DINT;
  lL_MemPhActStoragetankAssignmentIndex     : ARRAY[1..iCPr_NB_PH] OF DINT;
  
 (*----- Inspection System -----*)
  bInspectionTrigger : BOOL;
  fbInspectionSystemTrigger                 : FB_InspectionSystemTrigger;   // Inspection system trigger 
  nInspectionSystemMarkIdx                  : INT := 3;

  // Neutral fibre calculation with additional mark sensors
  fbNeutralFibreDetermine                   : FB_NeutralFibreDetermine;    // Neutral fibre determine 
  
  (*----- Logging -----*)
  LogPrSetup                                : T_NamedBase;  // just a I_LogSourceMacro implementation (logging PRINT module setup things)
  
  (*----- Messages -----*)
  fb_Msg                                    : ARRAY [1..iC_NUM_MSG] OF FB_MESSAGE; (*global Module messages*)
    
  (* -- Recipe read/write auto-management*)
  pFbRecipeMngr                             : POINTER TO FB_RECIPE_READ_WRITE;
  
  
  
 // >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>><<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
 // TO CLEANUP
 // || || || || || || ||
 // V  V  V  V  V  V  V 
  //lCtr, lCtr2                               : DINT;           (*local iteration counter - default*)
  //iL_I, iL_I2                               : INT;            (*instance counter*)
  iCT                                       : I_CT;

  (*Infos from other tasks*)
  //bL_PrintMarksExist                        : ARRAY [1..iCPr_NB_PM] OF BOOL;             (*PRG_MACHINE*)


  
  (*----- print, offfset and motion variables ------*)
  // Trigger & Offsets
  //bL_StartTrigger                           : ARRAY [1..iCPr_NB_PM] OF BOOL;       (*Start Trigger for X0*)
  //rT_StartTrigger                           : ARRAY [1..iCPr_NB_PM] OF R_TRIG;
  nL_X0                                     : ARRAY [1..iCPr_NB_PM] OF DINT;       (*detected X0 position*)
  nL_X0_Comp                                : ARRAY [1..iCPr_NB_PM] OF DINT;       (*detected & adapted X0 start position*)
  nL_XS                                     : ARRAY [1..iCPr_NB_PG] OF DINT;       (*Shifted position of start print in pulse*)
  // Some print parameter

  bL_HardwareHold                           : ARRAY [1..iCPr_NB_PM] OF BOOL;   (*suspend/stop worker*)

  (*VISU show control*)
  bL_Manu_StartTrigger                      : ARRAY [1..iCPr_NB_PM] OF BOOL;   (*Manual StartTrigger*)
  
  (*-- configs*)
  bL_InitRemVar                             : BOOL := TRUE;

  //fL_ResolutionEncoder                      : ARRAY [1..iCPr_NB_PM] OF LREAL;  (*resolution of encoder [um/increment]*)
  //fL_ResolutionPhPxDriftContr               : ARRAY [1..iCPr_NB_PM] OF LREAL;  (*resolution of encoder with drift contr correction [um/increment]*)
  //iL_ResolutionPhPx                         : ARRAY [1..iCPr_NB_PU] OF INT;    (*printhead pixel resolution [dpi]*)
  //iL_ResolutionSubPx                        : ARRAY [1..iCPr_NB_PU] OF INT;    (*subpixel pulse resolution [pulse/px]*)
//  fL_Pg_xOffset                             : ARRAY [1..iCPr_NB_PG] OF LREAL;  (*static offset of print group from start detection [m]*)
//  fL_Calc_Pg_xOffset                        : ARRAY [1..iCPr_NB_PG] OF LREAL;  (*helper variable, calculated offset of PG [m]*)
  //fL_Pg_vStartShiftFactor                   : ARRAY [1..iCPr_NB_PU] OF LREAL;  (*shift of virtual start signal factor from detection towards print group [s]*)
  //fL_Pg_vStartShiftOffset                   : ARRAY [1..iCPr_NB_PU] OF LREAL;  (*shift of virtual start signal value from detection towards print group [m]*)
  //fL_Pg_vStartShift                         : ARRAY [1..iCPr_NB_PG] OF LREAL;  (*delta distance of virtual start signal shift [m]*)
  //fL_Pg_ShiftPosXScaled                     : ARRAY [1..iCPr_NB_PG] OF LREAL;  (*Shift(offset) X print position scaled with stretch factor [um]*)
  //fL_SubstrateLen                           : ARRAY [1..iCPr_NB_PU] OF REAL;   (*length of substrate [m]*)
  //iL_PuFirstEnabledPc                       : ARRAY [1..iCPr_NB_PU] OF INT;


  
  


  


  iWorker                                   : I_Worker;
//  fbWorkerWeu                               : ARRAY[1..iCPr_NB_PG] OF FB_WorkerWeu_Print;
  stGroupStatus                             : ARRAY[1..iCPr_NB_PG] OF ST_PG_STATUS;  (*Group status*)
  stPcFlags                                 : ARRAY[1..iCPr_NB_PG] OF CalmarCompPrint.ST_PC_FLAGS;
  iActiveCt                                 : ARRAY[1..iCPr_NB_PM] OF I_CT;

  // Print module synchronisation
  fbModuleSynchronisation                   : FB_ModuleSynchronisation;
  bL_DisableModuleSynchronisation           : BOOL;   (*Visu: disable ModuleSynchronisation*)
  
  (*Test / Debug / View -----------------------------*)  
  (* Simulation *)
  fSimSpeed                                 : LREAL := 1;   // simulation speed
  bSimPosition                              : BOOL;         // simulate encoder 

  fbRTrigStartPositionSimulation            : R_TRIG;
  bL_SimMarkStartActive                     : ARRAY [1..iCPr_NB_PM] OF BOOL;   (*start trigger simulation active*)
  bL_SimMarkStartTrigger                    : ARRAY [1..iCPr_NB_PM] OF BOOL;   (*start trigger simulation*)
  nL_SimMarkStartTriggerPos                 : ARRAY [1..iCPr_NB_PM] OF DINT;   (*start trigger simulation DeltaX*)
  bL_DisableSimMarkStartTriggerM3           : BOOL;                            (*disable start trigger simulation for module 3 (mark is printed with module 2)*)
  bL_DisableDelayTriggerDistanceM3          : BOOL;                            (*disable delay for start trigger simulation for module 3*)
  fbRTrigMarkSelectNormal                   : R_TRIG;                          (*inverted marks in case of wrong mirrored prints*)
  fbRTrigMarkSelectInverted                 : R_TRIG;                          (*inverted marks in case of wrong mirrored prints*)
  
  (*Visualisations*)
  fb_visu_pu                                : FB_PU_Visu;
  fb_visu_pc                                : FB_PC_Visu;
  fb_visu_ph                                : FB_PH_Visu;
  iL_SelPh                                  : INT := 1;   (*Local Variables for PLC Visu*)
  iL_SelPhPc                                : INT := 1;
  iL_SelPc                                  : INT := 1;
  iL_SelPg                                  : INT := 1;
  iL_SelPu                                  : INT := 1;
  nVisuSelection_Ph                         : UINT := 1;
  nServiceVisuFrameIndex                    : UINT := 0;   // VISU_SERVICE frame selection
  nSelectPmView                             : UDINT := 1;  // visu pm selection

  (*Debug & Insight*)
  fbPrgPrintTest                            : FB_PrgPrint_test;
  ePrint_LogLevel                           : E_LogSeverity  := E_LogSeverity.Debug;
  fbProfiler                                : FB_PrgProfiler;
END_VAR

VAR PERSISTENT
  lPrintOffsetXs                            : DINT;  (*[SubPx]*)
  bMarksInverted                            : BOOL;                            (*inverted marks in case of wrong mirrored prints*)
END_VAR

VAR CONSTANT
(*GENERAL*)
(*************************************************************************************************)
  

  
    
  iC_yShiftOffset                           : INT := (2048-1280)/2;  (*[px]*)
  iC_yShiftMin                              : INT := 0;              (*[px]*)
  iC_yShiftMax                              : INT := (2048-1280);    (*[px]*)

  (*Messaging*)
	iC_NUM_MSG                                : INT := 5;
	iC_MSG_1_FOE_MASK_ERR                     : INT := 1;
	iC_MSG_2_FOE_WAVEFORM_ERR                 : INT := 2;
  iC_MSG_3_FOE_CBFW_ERR                     : INT := 3;
  iC_MSG_4_FOE_HIBFW_ERR										: INT := 4;
  iC_MSG_5_PC_SUPPLY_OFF                    : INT := 5;

  (*Job sequence steps*)
	cJobSeqStepIdle                           : INT := 0;
	cJobSeqStepReady                          : INT := 1;
	cJobSeqStepStartCT                        : INT := 2;
	cJobSeqStepPrintReady                     : INT := 3;
	cJobSeqStepPrintActive                    : INT := 4;
	cJobSeqStepPrintDone                      : INT := 5;
	cJobSeqStepComplete                       : INT := 6;
	cJobSeqStepCompleteDelay1                 : INT := 7;
	cJobSeqStepCompleteDelay2                 : INT := 8;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[(* INIT First action init call*)
IF NOT bO_InitOk THEN
  Init();
  RETURN;
END_IF;

(* Call ACTIONS *)
(*************************************************************************************************)
Control();          (*Controlling part*)
DownloadFiles();    (*Call file downloads*)
RemVar();           (*Call update remanent data action*)
Testing();          (*Call test code*)
Visu();             (*Call visualisation control*)

// Setup MACHINE information - TODO: handle this in PRG_MACHINE 
FOR nCtr := 1 TO TO_UDINT(iCPr_NB_PM) DO
  sModuleMachineState[nCtr].bPrinterHood           := PRG_MACHINE.bIKp_SafetyCoverOK[nCtr];
  sModuleMachineState[nCtr].bServiceDoors          := PRG_MACHINE.bIKp_SafetyDoorsOK[nCtr];
  sModuleMachineState[nCtr].bExhaustVacuumWarning  := PRG_MACHINE.fb_ExhaustSystem[nCtr].bO_VacuumWarningLevel;
  sModuleMachineState[nCtr].bExhaustVacuumError    := PRG_MACHINE.fb_ExhaustSystem[nCtr].bO_VacuumErrorLevel;
  sModuleMachineState[nCtr].bExhaustFUError        := FALSE; // NOT fb_ExhaustSystem[1].bO_FUReady
  sModuleMachineState[nCtr].bDriftControlError     := FALSE; // fB_DriftControl[nCtr].bO_SupervisionContrErr OR fB_DriftControl[nCtr].bO_ContrErr;
  sModuleMachineState[nCtr].bDriftControlMissMarks := FALSE; // fB_DriftControl[nCtr].bO_SupervisionMissMarks;
  sModuleMachineState[nCtr].bSafetyNOk             := NOT PRG_MACHINE.bL_SafetyOk[nCtr];
  
  // new
  sModuleMachineState[nCtr].bUnitInPrintPosition   := PRG_MACHINE.fb_CleaningPU[nCtr].pInPosPrint;
  sModuleMachineState[nCtr].bEngaged               := PRG_MACHINE.bL_IO_Engaged[nCtr] OR PRG_MACHINE.bL_SimMachineReady;
  sModuleMachineState[nCtr].bPrintEnabled          := (PRG_MACHINE.IbEAP_PrintEnabled[nCtr] AND PRG_MACHINE.fb_CleaningPU[nCtr].pInPosPrint) OR PRG_MACHINE.bL_SimMachineReady;
  
  // other
  sModuleMachineState[nCtr].fSubstrateThickness    := DINT_TO_REAL(PRG_MACHINE.InEAP_SubstrateThickness) / 1_000_000;    (*[µm] => [m]*) 
  sModuleMachineState[nCtr].fSubstrateLen          := DINT_TO_REAL(PRG_MACHINE.InEAP_FormatLength) / 1_000_000;    (*[µm] => [m]*) 
  sModuleMachineState[nCtr].fWebStretchCalculated  := (1.0 - (DINT_TO_LREAL(PRG_MACHINE.InEAP_WebStretchFactor) / 1_000_000));
  sModuleMachineState[nCtr].nLateralRegister       := PRG_MACHINE.InEAP_LateralRegister;
  sModuleMachineState[nCtr].nModule2ToModule3      := PRG_MACHINE.InEAP_Module2ToModule3;
  sModuleMachineState[nCtr].bTargetSpeedReached    := PRG_MACHINE.IbEAP_TargetSpeedReached;
  sModuleMachineState[nCtr].nNeutralFibreFactor    := PRG_MACHINE.InEAP_NeutralFibreFactor;
  sModuleMachineState[nCtr].bMarksExist            := PRG_MACHINE.IbEAP_PrintMarksExist[nCtr];
  sModuleMachineState[nCtr].bMarksInverted         := bMarksInverted;

  FOR nCtr2 := 1 TO TO_UDINT(GVL_WEU.nC_WorkerPrintPerPm) DO
    fbPrintModule[nCtr].bEnableWorker[nCtr2]       := sAdsPrintGroup[nCtr2 + TO_UDINT(iCPr_MAP_PM_PG[nCtr2])-1].bI_Enable;
    {warning 'TODO: scale X Offset with fL_WebStretchCalculated?'}
    fbPrintModule[nCtr].fPrintOffsetX[nCtr2]       :=  TO_LREAL(sAdsPrintUnit[ePr_PU_UNIT_1].sI_ShiftJobX.lI_Val) / 1_000_000 	// PU [um] to [m]
                                                     + TO_LREAL(sAdsPrintModule[nCtr].sI_GeneralShiftX.lI_Val) / 1_000_000 	  // PG [um] to [m]
                                                     + TO_LREAL(sAdsPrintGroup[nCtr2 + TO_UDINT(iCPr_MAP_PM_PG[nCtr2])-1]) / 1_000_000;
    fbPrintModule[nCtr].fPrintOffsetY[nCtr2]       :=  DINT_TO_LREAL(F_MeterToSubPixel(DINT_TO_LREAL(sAdsPrintUnit[ePr_PU_UNIT_1].sI_ShiftJobY.lI_Val ) / 1_000_000, nC_PrintResolution))   (*[um] to [px] job yOffset from upper level (GUI)*)
                                                     + DINT_TO_LREAL(F_MeterToSubPixel(DINT_TO_LREAL(sAdsPrintModule[nCtr].sI_GeneralShiftY.lI_Val )    / 1_000_000, nC_PrintResolution))   (*[um] to [px] job yOffset from upper level (GUI)*)
                                                     + DINT_TO_LREAL(F_MeterToSubPixel(DINT_TO_LREAL(sAdsPrintGroup[nCtr2 + TO_UDINT(iCPr_MAP_PM_PG[nCtr2])-1].sI_ShiftPositionY.lI_Val) / 1_000_000, nC_PrintResolution));   (*[um] to [px] job yOffset from upper level (GUI)*)
                                                      
	END_FOR
    
  fbPrintModule[nCtr]();
END_FOR


// Module Control & Synchronization
// - Controls the Reference (Master Module)
// - Setups the ProdMngr CT Handling depending on used master module
// - Configured the positioning depending on used master module
bMasterTrigger  := SEL(fbPrintModule[1].bEngaged, fbPrintModule[2].bStart, fbPrintModule[1].bStart);
fMasterSpeed    := SEL(fbPrintModule[1].bEngaged, fbPrintModule[2].fMasterSpeed, fbPrintModule[1].fMasterSpeed);
nMasterPosition := SEL(fbPrintModule[1].bEngaged, fbPrintModule[2].nPos_SubPx, fbPrintModule[1].nPos_SubPx);



// Print module synchronisation (simulation not for production)
(*
fbModuleSynchronisation( IbEnable           := NOT bL_DisableModuleSynchronisation
                       , IbEngaged          := bL_Engaged
                       , IbPrintEnabled     := bL_PrintEnabled
                       , InFormatLength     := nL_FormatLength
                       , InModule2ToModule3 := nL_Module2ToModule3
                       , IbFormatTrig       := bL_StartTrig
                       , ObPrintEnabled     => bL_PrintEnabledSync); 
*)


(* -- PM PrintModule*)
FOR iL_I := 1 TO iCPr_NB_PM DO

(*
  (*Paper position & start detection*)
  Fb_PaperPosDetect[iL_I].bReset                 := bL_ResetPosition[iL_I] OR bL_HardwareSync[iL_I];  (*AutoReset*)
  Fb_PaperPosDetect[iL_I].bI_WithMark              := TRUE;
  Fb_PaperPosDetect[iL_I].bI_MarksInverted         := bMarksInverted;
  Fb_PaperPosDetect[iL_I].fCurrentSpeed         := LREAL_TO_REAL(Fb_Ref_Master[iL_I].fO_Master_Speed);
  Fb_PaperPosDetect[iL_I].nCurrentPos            := Fb_Ref_Master[iL_I].lO_Master_Position;
  Fb_PaperPosDetect[iL_I].iI_Resolution            := iL_ResolutionSubPx[ePr_PU_UNIT_1] * iL_ResolutionPhPx[ePr_PU_UNIT_1];
  Fb_PaperPosDetect[iL_I].fResolution            := iL_ResolutionSubPx[ePr_PU_UNIT_1] * fL_ResolutionPhPxDriftContr[iL_I];
  Fb_PaperPosDetect[iL_I].fI_MarkLength            := sAdsSheetAlignment[ePr_PU_UNIT_1].sI_PrintMarkSizeX.fI_Val / 1_000;
  Fb_PaperPosDetect[iL_I].fI_MarkHeight            := sAdsSheetAlignment[ePr_PU_UNIT_1].sI_PrintMarkSizeY.fI_Val / 1_000;
  Fb_PaperPosDetect[iL_I].fSubstrateLength       := fL_SubstrateLen[ePr_PU_UNIT_1];
  Fb_PaperPosDetect[iL_I].bI_SimTriggerActive      := bL_SimMarkStartActive[iL_I];      // StartTrigger Simulation VISU&FB
  Fb_PaperPosDetect[iL_I].bI_ManualTrigger         := bL_SimMarkStartTrigger[iL_I];     // StartTrigger Simulation VISU&FB
  Fb_PaperPosDetect[iL_I].iI_ManualTriggerPosition := nL_SimMarkStartTriggerPos[iL_I];  // StartTrigger Simulation VISU&FB
  Fb_PaperPosDetect[iL_I].bEnable                  := bL_TargetSpeedReached AND (bL_MachineUpper5MpMin[1] OR bL_MachineUpper5MpMin[2]);
  Fb_PaperPosDetect[iL_I]();
*)

  (*Start Trigger & X0 selection*)
  bL_StartTrigger[iL_I] := Fb_PaperPosDetect[iL_I].bStartTrig OR bL_Manu_StartTrigger[iL_I];
  rT_StartTrigger[iL_I](CLK:=bL_StartTrigger[iL_I]);
  IF bL_Manu_StartTrigger[iL_I] THEN
    nL_X0[iL_I]           := Fb_Ph_Master[iL_I].lO_Master_Position;
  ELSE 
    nL_X0[iL_I]           := Fb_PaperPosDetect[iL_I].nOffset_X0;
	END_IF
  
  (*XO apply SpeedCompensation and GeneralShift*)
   nL_X0_Comp[iL_I] := nL_X0[iL_I]
                       - FC_REAL_TO_DINT(fL_SpeedComp[iL_I] * (1 / (0.0254 / (nC_PrintResolution * nC_SubPixelResolution))))
                       - FC_CONV_M_TO_SUBPX( DINT_TO_LREAL(sAdsPrintModule[iL_I].sI_GeneralShiftX.lI_Val) / 1_000_000, nC_PrintResolution, nC_SubPixelResolution);

END_FOR



// ----------------------------------------------------
// -- CT and ProdMngr (Production Management)
//done in MASTER module: fBCTManagerMain.nPositions[E_PosDomain.master_pos] := nMasterPosition;
//done in MASTER module: fBCTManagerMain.nPositions[E_PosDomain.pos_px]     := nMasterPosition/TO_DINT(nC_SubPixelResolution);
fBCTManagerMain();

// CT Control in ProductionManager
// - on MASTER StartTrigger (or directly on ProdMngr)
// - 

//IF fbPm.bReady 
//iActiveCt[iL_I] := fBCTManager.CreateCT();
//iCT := fBCTManager.getCT(nIdx := 1)
//fBCTManager.DestroyCT(iCT := iCT);
//fbPm.CT_Create(sCT := iActiveCt[iL_I]); 
// setup new CT
//iActiveCt[iL_I].bProductPresent := PRG_MACHINE.bL_MemMachineOn OR PRG_MACHINE.bL_SimMachineReady;
//iActiveCt[iL_I].SetPosX0(nPosDomain := E_PosDomain.master_pos, nXO := nL_X0_Comp[iL_I]); 
//iActiveCt[iL_I].SetPosX0(nPosDomain := E_PosDomain.pos_px,     nXO := nL_X0_Comp[iL_I] / TO_DINT(nC_SubPixelResolution));
//// produce CT
//fbPm.CT_Produce(sCT := iActiveCt[iL_I]);   // produce this CT
//// Finish CT
//fbPm.CT_Finish(sCT := iActiveCt[iL_I], bSuccess := TRUE);   // finish last CT



// --------------------------------------------------------
// Worker chain  --> call all work() methods
iWorker := fbWorkerDelete.Root;
WHILE iWorker <> 0 DO
  iWorker.work();
  iWorker := iWorker.Next;
END_WHILE

// --------------------------------------------------------
// Print Blocks
fbOd();
fbPm();

(* -- PU PrintUnit*)
// PG->PU status/flags 
FOR nCtr := 1 TO TO_UDINT(iCPr_NB_PU) DO 
  // specific handling
  fb_RTrigStopRequestVarnishChange(CLK := (PRG_INK.bO_CommandPrintlineExec[1] AND bL_Engaged[1]) OR (PRG_INK.bO_CommandPrintlineExec[2] AND bL_Engaged[2]));       (*If varnish change is activated the job should be stopped.*)
  IF fb_RTrigStopRequestVarnishChange.Q THEN FB_PU[iL_I].reqPuStop('Stop VarnishChange'); END_IF
  
  FB_PU[nCtr]();
  
  // WEU Start CanEx override
  sAdsPrintUnit[iL_I].sI_Start.bO_CommandCanEx := sAdsPrintUnit[iL_I].sI_Start.bO_CommandCanEx 
                                                AND NOT PRG_MACHINE.sO_SystemCmd.bSleep     // sleep active
                                                AND (NOT PRG_INK.bO_CommandPrintlineExec[1] OR NOT bL_Engaged[1])    //? varnish exchange M2
                                                AND (NOT PRG_INK.bO_CommandPrintlineExec[2] OR NOT bL_Engaged[2]);   //? varnish exchange M3
END_FOR

//Hardware
fbHardwarePool();


(* -- PG PrintGroup*)
FOR nCtr := 1 TO TO_UDINT(iCPr_NB_PG) DO
  sAdsPrintGroup[nCtr].aO_State := 'no info'; //fbPrintModule[iCPr_MAP_PG_PM[nCtr]]. ;
  sAdsPrintGroup[nCtr].lO_Error := 0; //fbPrintModule[iCPr_MAP_PG_PM[nCtr]]. ; 
  sAdsPrintGroup[nCtr].bO_Error := fbPrintModule[iCPr_MAP_PG_PM[nCtr]].bError;
END_FOR

(* -- PC PrintController*)
FOR nCtr := 1 TO TO_UDINT(iCPr_NB_PC) DO
  FB_PC[nCtr].sI_SystemCmd := PRG_MACHINE.sO_SystemCmd;  {warning 'TODO: Must be done internally'}
  FB_PC[nCtr]();
END_FOR


// Inspection system
{warning '???was soll diese Zeile'}
IF (nInspectionSystemMarkIdx > 3) OR (nInspectionSystemMarkIdx < 2) THEN nInspectionSystemMarkIdx := 3; END_IF  (*Index check*)
fbInspectionSystemTrigger.UsePositionTrigger := fbStartPositionSimulationHOA._bSim AND NOT bL_DisableSimMarkStartTriggerM3;
(*input bI_SensorState depends on _bUsePositionTrigger*)
IF fbInspectionSystemTrigger.UsePositionTrigger THEN
  fbInspectionSystemTrigger.bI_SensorState := bMasterTrigger;
ELSE
  fbInspectionSystemTrigger.bI_SensorState := Fb_PaperPosDetect[nInspectionSystemMarkIdx - 1].bIKp_StartSensor;
END_IF

fbInspectionSystemTrigger( iI_CurrentPos         := nMasterPosition
                         , fI_ConveyorSpeed      := fMasterSpeed
                         , iI_SensorX0           := SEL(bL_Engaged[1], nL_X0[2]                           , nL_X0[1])
                         , tI_SensorTimeStampPos := Fb_PaperPosDetect[nInspectionSystemMarkIdx - 1].tIKp_TimeStampPos
                         (*StartTrigger Simulation VISU&FB*)
                       //, bI_ManualTrigger      := fbStartPositionSimulation.bStartTrig
                         );

// Neutral fibre calculation with additional mark sensors
fbNeutralFibreDetermine(fSpeed := fMasterSpeed);

 
(****************************************************************************)
(* Global states *)
(* ------------------------------------------------------------------------ *)
bO_PrintSystemOk := fbPm.bReady;
(*WcState: 0 = Data valid, 1 = Data invalid*)
bO_TotalWcState :=    bI_EncoderWcState[1]
                   OR bI_EncoderWcState[2];


(********************************* END OF PRG ****************************************************)]]></ST>
    </Implementation>
    <Folder Name="AdsSetup" Id="{122d5687-48dc-48ad-b1e2-8708d0134afe}" />
    <Action Name="Control" Id="{99d59eb8-3e0f-49c7-8b92-44c6dc42d2a6}">
      <Implementation>
        <ST><![CDATA[(*======================================================*)
(*--- START: Profiling ---*)
  fbProfiler();
(*--- END: Profiling ---*)
(*======================================================*)


(*======================================================*)
(*--- START: Messaging ---*)
(* Messaging, NOTE: they are using the FB_PU message handler! *)
fb_Msg[iC_MSG_1_FOE_MASK_ERR]    .bI_Status := fb_fdl_mask.bO_Error;
fb_Msg[iC_MSG_2_FOE_WAVEFORM_ERR].bI_Status := FALSE;  //bWaveformDownloadErr; // fb_fdl_waveform.bO_Error;
fb_Msg[iC_MSG_3_FOE_CBFW_ERR]    .bI_Status := fb_fwhw_update.bL_Upd_Error;
fb_Msg[iC_MSG_4_FOE_HIBFW_ERR]   .bI_Status := fb_hib_rup.bL_Error;
fb_Msg[iC_MSG_5_PC_SUPPLY_OFF]   .bI_Status := FALSE; //TODO: NOT PRG_MACHINE.sL_CvyrStatus.bI_PowerState;

FOR lCtr := 1 TO iC_NUM_MSG DO
  IF fb_Msg[lCtr].pI_MsgConfig <> 0 AND fb_Msg[lCtr].iI_MsgNumber <> 0 THEN
    fb_Msg[lCtr]();
  END_IF
END_FOR
(* --- END: messaging --- *)
(*======================================================*)


(********************************* END OF ACTION *************************************************)]]></ST>
      </Implementation>
    </Action>
    <Method Name="DownloadFiles" Id="{01e70b04-413b-4361-8a70-6ae64ebdd1be}">
      <Declaration><![CDATA[METHOD DownloadFiles
VAR
  sPcFlags : ST_PC_FLAGS;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[(* PC firmware updater*)
(*    uses PC[x] FoE channel *)
(* ------------------------------------------------------------------------ *)
(* --- START: --- *)
//fb_fwhw_update( pI_fbPc := pFB_PC^);
(* --- END: --- *)


(****************************************************************************)
(* HIB remote update*)
(*    uses PC[x] FoE channel *)
(* ------------------------------------------------------------------------ *)
(* --- START: --- *)
//fb_hib_rup();
(* --- END: --- *)


(****************************************************************************)
(* mask update*)
(*		uses PC[x] FoE channel *)
(* ------------------------------------------------------------------------ *)
(* --- START: printhead mask loader --- *)
(*FOR lCtr := 1 TO iCPr_NB_PC DO
  IF FB_PC[lCtr].sO_PcFlags.bBoardEnterOp THEN 
    fb_fdl_mask.Start(DINT_TO_INT(lCtr));    // start individual channel
	END_IF
END_FOR;*)
fb_fdl_mask();
(* --- END: printhead mask loader --- *)


(****************************************************************************)
(* Waveform update*)
(*    uses PC[x] FoE channel *)
(* ------------------------------------------------------------------------ *)
(* --- START: printhead waveform loader --- *)
bWaveformDownloadErr := FALSE;
FOR lCtr := 1 TO iCPr_NB_PC DO
  sPcFlags := FB_PC[lCtr].sPcFlags;
  bL_waveform_request[lCtr] := tOn_waveform[lCtr].Q;
  IF    ( sPcFlags.bBoardEnabling ) 
     OR ( bL_waveform_request[lCtr] ) //filtered internally: AND NOT fb_fdl_waveform[iL_Counter].bO_Busy AND (tTimeoutWavef[iL_Counter].Q OR fb_Wavef_CfgTrig[iL_Counter].Q)
  THEN
    fb_fdl_waveform.Start(DINT_TO_INT(lCtr));    // start individual channel
  END_IF

  tOn_waveform[lCtr](IN:=sPcFlags.bWaveform AND NOT bL_waveform_request[lCtr], PT:= T#14S);

  // build global request for message
  IF sPcFlags.bWaveform AND FB_PC[lCtr].bBoardEnable THEN 
    bWaveformDownloadErr := TRUE;
	END_IF
END_FOR;
fb_fdl_waveform();

(*Assign WaveFileName from storage tank to PH. Trigger transmit of waveform if new name is set.*)
FOR lCtr := 1 TO iCPr_NB_PH DO
  lL_PhActStoragetankAssignmentIndex[lCtr] := PRG_INK.iL_ActStoragetankAssignmentIndex[iCPr_MAP_PH_HT[lCtr]];

  (*If lL_PhActStoragetankAssignmentIndex is assigned to a storage tank the waveform must be copied.*)
  IF     (lL_PhActStoragetankAssignmentIndex[lCtr] > 0)
     AND (lL_PhActStoragetankAssignmentIndex[lCtr] <> lL_MemPhActStoragetankAssignmentIndex[lCtr])
  THEN
    // set new waveform name to PH
    sAdsPrintHead[lCtr].aI_WaveFileName := PRG_INK.sAdsIkInkStorageTank[lL_PhActStoragetankAssignmentIndex[lCtr]].sI_InkParameter.aWaveform;
    
    (*Fix extension if not existing in the file name*)
    IF (FIND(sAdsPrintHead[lCtr].aI_WaveFileName, '.wav') = 0) AND (FIND(sAdsPrintHead[lCtr].aI_WaveFileName, '.WAV') = 0) THEN
      sAdsPrintHead[lCtr].aI_WaveFileName := CONCAT(sAdsPrintHead[lCtr].aI_WaveFileName, '.wav');
    END_IF

    (*check for valid file name*)
     IF sAdsPrintHead[lCtr].aI_WaveFileName = 'undef.wav' OR sAdsPrintHead[lCtr].aI_WaveFileName = '.wav' OR sAdsPrintHead[lCtr].aI_WaveFileName = '' THEN
       LogPrSetup.LogError(F_Concat5('Invalid filename: ', sAdsPrintHead[lCtr].aI_WaveFileName, ' on PH[', TO_STRING(lCtr),']'));
		 END_IF
  END_IF

  lL_MemPhActStoragetankAssignmentIndex[lCtr] := lL_PhActStoragetankAssignmentIndex[lCtr];
END_FOR

]]></ST>
      </Implementation>
    </Method>
    <Method Name="init" Id="{8ed4b07f-793b-45e7-ba14-620fabec907a}">
      <Declaration><![CDATA[METHOD Init : BOOL
VAR
  nCtr : UDINT;
  nPhCtr : UDINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[(*************************************************************************************************)
(* --- Module preprarations --- *)

// Get system reference
IF ISystemBase = 0 THEN
  ISystemBase := PRG_SYSTEMBASE.getSystemBaseInterface();
  IF ISystemBase = 0 THEN 
    RETURN; 
  END_IF
END_IF
  
// Wait until system(base) is booted
IF ISystemBase.bBooting THEN RETURN; END_IF

// Build mapping information for ADS
Mapping();

// Register module to system
pModuleDef := ISystemBase.regModule(
  pAdsInfo := ADR(sC_Ads_Info),
  pMapInfo := ADR(sMappingInfo)
);
IF pModuleDef = 0 THEN RETURN; END_IF

// Init configuration 
IF bL_InitRemVar THEN RemVar();	END_IF	(*force read of persistence before init*)



(*************************************************************************************************)
(* Init FB and ADS instances*)
nYShift_center :=  (nC_MemorySectionWidth - TO_UDINT(GVL_PrintDef.RIGEN5.iC_Ph_Width)) / 2;     // [px] 384px for RICOH_GEN5

setLoggingLevels();

(*-- Print blocks init --------------------------------------------------------------------------*)
(*-- CoE object dicionary*)
fbOd.init(aAmsNetId:=sC_AMSNETID_LOCALHOST, aFilePath:=F_Concat3(aC_PlcConfigPath, aC_PlcFlashFileSubPath, 'od.json'), pSimString:=0);

(* -- PU PrintUnit*)
FOR nCtr := 1 TO TO_UDINT(iCPr_NB_PU) DO
	(*-- ADS --*)
  setupAdsPu(pAds:=ADR(sAdsPrintUnit[nCtr]));
  setupAdsSa(pAds:=ADR(sAdsSheetAlignment[nCtr]));
  
	(*-- FB --*)
  sPuSettings.bStopAfterDone := FALSE;
  FB_PU[nCtr].Init(                                                  (*Init referenced & config for FB*)
                    pAdsIf        := ADR(sAdsPrintUnit[nCtr])        (*> ads pu reference*)
                  , pAdsSubstrate := ADR(sAdsSubstrate[1])           (*> ads substrate ref*)
                  , pPuSettings   := ADR(sPuSettings)
                  , iNumPg        := iCPr_NB_PM                      (*> Number print SubSystems*)
                  );
END_FOR;

FOR nCtr := 1 TO TO_UDINT(iCPr_NB_PM) DO
	(*-- ADS --*)
  setupAdsPm(pAds:=ADR(sAdsPrintModule[nCtr]), nIdx:=nCtr);
  
  (*-- FB -- *)
  fbPrintModule[nCtr].Init( nIdx     := TO_UDINT(nCtr)
                          , pAdsPm   := ADR(sAdsPrintModule[nCtr])
                          , pAdsSa   := ADR(sAdsSheetAlignment[ePr_PU_UNIT_1])
                          , fPrintResolution := nC_PrintResolution
                          , fSubPxResolution := nC_SubPixelResolution
                          , nYShift_PcRamCenter := (nC_MemorySectionWidth - TO_UDINT(GVL_PrintDef.RIGEN5.iC_Ph_Width)) / 2     // [px] 384px for RICOH_GEN5
                          , fTaskCycleTime := pModuleDef^.fCycleTime_s
                          , pModuleMachineInterface := sModuleMachineState[nCtr]
                          , pCTManager := ADR(fBCTManagerMain)
                          , iProdManager := fbPm
  );
  FB_PU[ePr_PU_UNIT_1].registerStatusClient(sClient := fbPrintModule[nCtr]);
  FB_PU[ePr_PU_UNIT_1].registerSubystem(sSubSys:=fbPrintModule[nCtr]); 
END_FOR;


(*Hardware Pool for PH - Print Head and PC - Print Controller*)
fBHardwarePool.init(
  sAmsNetIdLocalhost  := sC_AMSNETID_LOCALHOST,
  sAmsNetIdIo         := sC_AMSNETID_IO,
  pOd                 := ADR(fbOd),
  pConfig             := ADR(sC_Config_P)
);
  
pFB_PC := fbHardwarePool.pPcs;  // used for FileDownload and global FBs managing all PCs


FOR nCtr := 1 TO TO_UDINT(iCPr_NB_PG) DO
	(*-- ADS --*)
  setupAdsPg(pAds:=ADR(sAdsPrintGroup[nCtr]), nIdx:=nCtr);

  (*-- IF direct access to PRG_INK --*)
  PRG_INK.pAdsPg[nCtr] := ADR(sAdsPrintGroup[nCtr]);  
END_FOR;

FOR nCtr := 1 TO TO_UDINT(iCPr_NB_PC) DO
	(*-- PC --*)
	FB_PC[nCtr].Init( pAds               := ADR(sAdsPrintController[nCtr])
                  , sAmsNetIdLocalHost := sC_AMSNETID_LOCALHOST
                  , sAmsNetIdIo        := sC_AMSNETID_IO
                  , nEcatSlaveAddr     := iG_PC_ADDRESS[nCtr]
                  , nBlockId           := ePr_BLK_PC
                  , pOd                := ADR(fbOd)
                  , tWaveDownload      := T#10S
                  );
  
  // hw enable inputs not existing -> enable initially
  FOR nPhCtr := 1 TO TO_UDINT(iCPr_NB_PH_PER_CONTROLLER) DO
    FB_PC[nCtr].bI_PhHwEnable[nPhCtr] := TRUE;
  END_FOR

	(*-- ADS --*)
  setupAdsPc(pAds:=ADR(sAdsPrintController[nCtr]), nIdx:=nCtr);
 
  fbHardwarePool.registerPc(sNewPc:=ADR(FB_PC[nCtr]));
END_FOR;


(*PH - Print Head*)
FOR nCtr := 1 TO TO_UDINT(iCPr_NB_PH) DO
	(*-- ADS --*)
  setupAdsPh(pAds:=ADR(sAdsPrintHead[nCtr]), nIdx:=nCtr);

  (*-- PH --*)
  FB_PH[nCtr].init( pAdsIf       := ADR(sAdsPrintHead[nCtr])
                  , sPhDef       := GVL_PrintDef.RIGEN5
                  , tTempMonitor := T#45S
                  );

  FB_PC[iCPr_MAP_PH_PC[nCtr]].registerPH(iPH := FB_PH[nCtr], nCh := cCPr_MAP_PH_PC_Index[nCtr]);
  
  fbHardwarePool.registerPh(pNewPh:=ADR(FB_PH[nCtr]));
END_FOR;

(*----SUBSTRATE init*)
FOR nCtr := 1 TO TO_UDINT(iCPr_NB_SUBSTRATE_DEVICES) DO
  setupAdsSub(pAds:=ADR(sAdsSubstrate[nCtr]), nIdx:=nCtr); 
END_FOR


(*-- Print management init ------------------------------------------------------------------*)
fbPm.LogLevel := ePrint_LogLevel;
fbPm.init( pPU    := ADR(FB_PU[ePr_PU_UNIT_1]) 
         , pAdsPU := ADR(sAdsPrintUnit[ePr_PU_UNIT_1]),
         );
fbPm();  // call it once for self-initialisation
FB_PU[ePr_PU_UNIT_1].registerStatusClient(sClient := fbPm);

(*-- Container management init ------------------------------------------------------------------*)
fBCTManagerMain.Init();

(*-- Worker init --------------------------------------------------------------------------------*)

// -- DefGrid_Eject
fbWorkerVerify.Init(pCtManager:= ADR(fBCTManagerMain), pParamMediator := fbDefGridParamMediator, pMsgConfig:=FB_PU[1].pO_MsgConfig, fPrintResolution := nC_PrintResolution, fSubPxResolution := nC_SubPixelResolution);
fbWorkerVerify.setPm(pPm:=ADR(fbPm));
fbWorkerVerify.reg();
fB_PU[ePr_PU_UNIT_1].registerStatusClient(sClient:=fbWorkerVerify);

// -- DefGrid_Delete
fbWorkerDelete.Init(pCtManager:= ADR(fBCTManagerMain), pParamMediator := fbDefGridParamMediator, pMsgConfig:=FB_PU[1].pO_MsgConfig, fPrintResolution := nC_PrintResolution, fSubPxResolution := nC_SubPixelResolution);
fbWorkerDelete.reg();
fB_PU[ePr_PU_UNIT_1].registerStatusClient(sClient:=fbWorkerDelete);


// register Emergency
(*FOR lCtr := 1 TO iCPr_NB_PG DO
  PRG_SYSTEMBASE.fbEmergency.mRegisterObserver(iObserver := fbWorkerWeu[lCtr]);
END_FOR*)


//(*File Downloader*)
(*Is now in HardwarePool*)

//(*************************************************************************************************)
//(* - firmware*)
//fb_fwhw_update.aI_appl_file_path := F_Concat3(aC_PlcConfigPath, aC_PlcFlashFileSubPath, 'user.appl');
//fb_fwhw_update.aI_fpga_file_path := F_Concat3(aC_PlcConfigPath, aC_PlcFlashFileSubPath, 'user.fpga');
//fb_fwhw_update( pI_fbPc := pFB_PC^);
//fb_fwhw_update.init();

//(* - hib remote upfate*)
//fb_hib_rup.bI_Enable   := TRUE;
//fb_hib_rup.aI_FilePath := F_Concat3(aC_PlcConfigPath, aC_PlcFlashFileSubPath, 'user.hib');
//fb_hib_rup( sI_Ary_Fb:=fb_pc_hib_rupd, pI_Ary_Fb_Pc:=pFB_PC^);


(*-- Mask file*)
fb_fdl_mask.bI_Enable                := TRUE;
fb_fdl_mask.aI_src_file_path         := CONCAT(aC_PlcConfigPath, aC_PlcMaskFileSubPath);
fb_fdl_mask.aI_src_file_name_default := 'mask.msk';
fb_fdl_mask.aI_dest_file_path        := 'mask.msk.msk';
FOR nCtr := 1 TO TO_UDINT(iCPr_NB_PC) DO
	FOR nPhCtr := 1 TO TO_UDINT(iCPr_NB_PH_PER_CONTROLLER) DO
		IF iCPr_MAP_PC_PH[nCtr, nPhCtr] <> -1 THEN
	    fb_fdl_mask.aI_src_file_names[nCtr, nPhCtr] := ADR(sAdsPrintHead[iCPr_MAP_PC_PH[nCtr, nPhCtr]].aI_MaskFileName);
		END_IF
	END_FOR
END_FOR
fb_fdl_mask(pI_fbpc:=pFB_PC^);
fb_fdl_mask.Init(
  aDownloaderName := 'Mask downloader',
  bFilePerPh      := TRUE,
  bDefaultFile    := FALSE,
  bShowDetail     := TRUE,
  bUseLock        := FALSE,
  bEnabledOnly    := TRUE,
  bFileNameChange := TRUE,
  bEnterOp        := TRUE,
  bEnabling       := TRUE,
  bUseRange       := FALSE,
  lColorRGB       := 16#FF0080FF,
  iRetryCount     := 0,
  tRetryTimeout   := T#8S,
);

(*-- waveform file*)
fb_fdl_waveform.bI_Enable                := TRUE;
fb_fdl_waveform.aI_src_file_path         := CONCAT(aC_PlcConfigPath, aC_PlcWaveformFileSubPath);
fb_fdl_waveform.aI_src_file_name_default := 'waveform.wav';
fb_fdl_waveform.aI_dest_file_path        := 'waveform.wav.wav';
FOR nCtr := 1 TO TO_UDINT(iCPr_NB_PC) DO
	FOR nPhCtr := 1 TO TO_UDINT(iCPr_NB_PH_PER_CONTROLLER) DO
		IF iCPr_MAP_PC_PH[nCtr, nPhCtr] <> -1 THEN
	    fb_fdl_waveform.aI_src_file_names[nCtr, nPhCtr] := ADR(sAdsPrintHead[iCPr_MAP_PC_PH[nCtr, nPhCtr]].aI_WaveFileName);
		END_IF
	END_FOR
END_FOR
fb_fdl_waveform(pI_fbpc:=pFB_PC^);
fb_fdl_waveform.Init(
  aDownloaderName := 'Waveform downloader',
  bFilePerPh      := FALSE,
  bDefaultFile    := FALSE,
  bShowDetail     := TRUE,
  bUseLock        := FALSE,
  bEnabledOnly    := TRUE,
  bFileNameChange := TRUE,
  bEnterOp        := TRUE,
  bEnabling       := TRUE,
  bUseRange       := FALSE,
  lColorRGB       := 16#FF9191C8,
  iRetryCount     := 0,
  tRetryTimeout   := T#9S,  
);


(*Messaging*)
(*************************************************************************************************)
(*NOTE: FB_PU[x].init() has to be called before*)
fb_Msg[iC_MSG_1_FOE_MASK_ERR].pI_MsgConfig       := FB_PU[1].pO_MsgConfig;
fb_Msg[iC_MSG_1_FOE_MASK_ERR].iI_MsgLocation     := ePr_BLK_PU;
fb_Msg[iC_MSG_1_FOE_MASK_ERR].iI_MsgNumber       := eCPr_FOE_MASK_DL_ERR;

fb_Msg[iC_MSG_2_FOE_WAVEFORM_ERR].pI_MsgConfig   := FB_PU[1].pO_MsgConfig;
fb_Msg[iC_MSG_2_FOE_WAVEFORM_ERR].iI_MsgLocation := ePr_BLK_PU;
fb_Msg[iC_MSG_2_FOE_WAVEFORM_ERR].iI_MsgNumber   := eCPr_FOE_WAVEFORM_DL_ERR;

fb_Msg[iC_MSG_3_FOE_CBFW_ERR].pI_MsgConfig       := FB_PU[1].pO_MsgConfig;
fb_Msg[iC_MSG_3_FOE_CBFW_ERR].iI_MsgLocation     := ePr_BLK_PU;
fb_Msg[iC_MSG_3_FOE_CBFW_ERR].iI_MsgNumber       := eCPr_FOE_CBFW_DL_ERR;

fb_Msg[iC_MSG_4_FOE_HIBFW_ERR].pI_MsgConfig      := FB_PU[1].pO_MsgConfig;
fb_Msg[iC_MSG_4_FOE_HIBFW_ERR].iI_MsgLocation    := ePr_BLK_PU;
fb_Msg[iC_MSG_4_FOE_HIBFW_ERR].iI_MsgNumber      := eCPr_FOE_HIBFW_DL_ERR;


// Inspection system
fbInspectionSystemTrigger.Init(nResolution := nC_PrintResolution * nC_SubPixelResolution, bUsePositionTrigger := FALSE);

// Neutral fibre calculation with additional mark sensors
fbNeutralFibreDetermine.Init(nResolution := nC_PrintResolution * nC_SubPixelResolution);


(*************************************************************************************************)
(* --- System servcices ---- *)

(* -- BlockId saving ----------------------------------------------------------------------------*)
PRG_SYSTEMBASE.fbBlockIdSave.registerModule(
  aI_StoragePath := CONCAT(aC_PlcConfigPath, aC_PlcBlockIdSubPath),
  pI_Ads_Info    := ADR(sC_Ads_Info)
);

// init finished
bO_InitOk := TRUE;

(**** END ****************************************************************************************)]]></ST>
      </Implementation>
    </Method>
    <Action Name="Mapping" Id="{3474f8f4-21b7-444b-aa57-e0a4510d71d7}">
      <Implementation>
        <ST><![CDATA[(*************************************************************************************************)
(*ADS blocks mapping definition*)
(*************************************************************************************************)
(*mapping of each block with his parents, type and index*)
(*unit -> root*)
sL_BLK_PU[1].iPMaps[1]    := FC_ADD_MAP(eSys_BLK_ROOT, 1);

(*Substrate -> root*)
sL_BLK_SUB[1].iPMaps[1]   := FC_ADD_MAP(eSys_BLK_ROOT, 1);

(*SheetAlignment -> unit*)
sL_BLK_SA[1].iPMaps[1]    := FC_ADD_MAP(ePr_BLK_PU, 1);

(*module*)
FOR lCtr := 1 TO iCPr_NB_PM DO
  (*modules -> unit*)
  sL_BLK_PM[lCtr].iPMaps[1] := FC_ADD_MAP(ePr_BLK_PU, 1);
END_FOR;

(*group*)
FOR lCtr := 1 TO iCPr_NB_PG DO
  (*groups -> module*)
  sL_BLK_PG[lCtr].iPMaps[1] := FC_ADD_MAP(ePr_BLK_PM, iCPr_MAP_PG_PM[lCtr]);
  (*groups -> header tank group*)
  sL_BLK_PG[lCtr].iPMaps[2] := FC_ADD_MAP(eIk_BLK_HEADERTANK_GROUP, iCPr_MAP_PG_HTG[lCtr]);
END_FOR;

(*controller*)
FOR lCtr := 1 TO iCPr_NB_PC DO
  (*controller -> group*)
  IF bCPr_PC_EXIST[lCtr] THEN
    sL_BLK_PC[lCtr].iPMaps[1] := FC_ADD_MAP(ePr_BLK_PG, iCPr_MAP_PC_PG[lCtr]);
  END_IF;
END_FOR;

(*printhead*)
FOR lCtr := 1 TO iCPr_NB_PH DO
  (*printhead -> print controller*)
  IF bCPr_PH_EXIST[lCtr] THEN
    sL_BLK_PH[lCtr].iPMaps[1] := FC_ADD_MAP(ePr_BLK_PC        , iCPr_MAP_PH_PC[lCtr]);
  END_IF;
END_FOR;


(*************************************************************************************************)
(* initialize module information (module and mapping) *)
(*************************************************************************************************)
sC_Ads_Info.bReady   := FALSE;
sC_Ads_Info.aType    := 'PRG_PRINT';
sC_Ads_Info.iVersion := 010000;			(*1.0.0*)
sC_Ads_Info.iType    := eMOD_PRINT;

sMappingInfo.init(lModId:=TO_UINT(eMOD_PRINT));
sMappingInfo.addBlkAry( iAdsBlockType := TO_UINT(ePr_BLK_PU),       aAdsBlockName := 'sAdsPrintUnit',       iAdsBlockVersion:= sAdsPrintUnit[1].iO_Version,                    iNbrBlocks := SIZEOF(sL_BLK_PU)/SIZEOF(sL_BLK_PU[1]),         pBlockArray := ADR(sL_BLK_PU));
sMappingInfo.addBlkAry( iAdsBlockType := TO_UINT(ePr_BLK_PM),       aAdsBlockName := 'sAdsPrintModule',     iAdsBlockVersion:= INT_TO_UINT(sAdsPrintModule[1].iO_Version),     iNbrBlocks := SIZEOF(sL_BLK_PM)/SIZEOF(sL_BLK_PM[1]),         pBlockArray := ADR(sL_BLK_PM));
sMappingInfo.addBlkAry( iAdsBlockType := TO_UINT(ePr_BLK_PG),       aAdsBlockName := 'sAdsPrintGroup',      iAdsBlockVersion:= INT_TO_UINT(sAdsPrintGroup[1].iO_Version),      iNbrBlocks := SIZEOF(sL_BLK_PG)/SIZEOF(sL_BLK_PG[1]),         pBlockArray := ADR(sL_BLK_PG));
sMappingInfo.addBlkAry( iAdsBlockType := TO_UINT(ePr_BLK_PC),       aAdsBlockName := 'sAdsPrintController', iAdsBlockVersion:= INT_TO_UINT(sAdsPrintController[1].iO_Version), iNbrBlocks := SIZEOF(sL_BLK_PC)/SIZEOF(sL_BLK_PC[1]),         pBlockArray := ADR(sL_BLK_PC));
sMappingInfo.addBlkAry( iAdsBlockType := TO_UINT(ePr_BLK_PH),       aAdsBlockName := 'sAdsPrintHead',       iAdsBlockVersion:= INT_TO_UINT(sAdsPrintHead[1].iO_Version),       iNbrBlocks := SIZEOF(sL_BLK_PH)/SIZEOF(sL_BLK_PH[1]),         pBlockArray := ADR(sL_BLK_PH));
sMappingInfo.addBlkAry( iAdsBlockType := TO_UINT(ePr_BLK_SA),       aAdsBlockName := 'sAdsSheetAlignment',  iAdsBlockVersion:= INT_TO_UINT(sAdsSheetAlignment[1].iO_Version),  iNbrBlocks := SIZEOF(sL_BLK_SA)/SIZEOF(sL_BLK_SA[1]),         pBlockArray := ADR(sL_BLK_SA));
sMappingInfo.addBlkAry( iAdsBlockType := TO_UINT(ePr_BLK_SUBSTRATE),aAdsBlockName := 'sAdsSubstrate',       iAdsBlockVersion:= INT_TO_UINT(sAdsSubstrate[1].iO_Version),       iNbrBlocks := SIZEOF(sL_BLK_SUB)/SIZEOF(sL_BLK_SUB[1]),       pBlockArray := ADR(sL_BLK_SUB));
sMappingInfo.bReady := TRUE;


(********************************* END OF ACTION *************************************************)]]></ST>
      </Implementation>
    </Action>
    <Method Name="RemVar" Id="{3987c6f2-0d6d-4799-9841-ca583af23f3b}">
      <Declaration><![CDATA[METHOD RemVar
VAR
  lCtr : INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[(*==== INIT ====*)
IF bL_InitRemVar THEN
  (*read remanet variables*)
  bL_InitRemVar := FALSE;

  (* -- Recipe read/write -------------------------------------------------------------------------*)
  IF pFbRecipeMngr = 0 THEN
    pFbRecipeMngr := PRG_SYSTEMBASE.fbRecipeAutoMngmt.register(
      aI_RecipePath           := CONCAT(aC_PlcConfigPath, aC_PlcRecipeSubPath),
      aI_RecipeDefinitionName := sC_Ads_Info.aType  (*is set in Mapping*)
    );
  END_IF

  (*load initial values if pattern was invalid*)
  IF sR_RemVar_P.aL_Pattern <> 16#ABCD THEN

    (*clear invalid persistence memory*)
    MEMSET(destAddr := ADR(sR_RemVar_P), 0, SIZEOF(ST_REM_VAR_P));
    
    (*initial boot values of project*)
    sR_RemVar_P.aL_Pattern := 16#ABCD;

    FOR lCtr := 1 TO iCPr_NB_PU DO

      sAdsSheetAlignment  [lCtr].bI_UsePrintMark         := TRUE;
      sAdsSheetAlignment  [lCtr].sI_PrintMarkSizeX.fI_Val:= 12.0; (*mm*)
      sAdsSheetAlignment  [lCtr].sI_PrintMarkSizeY.fI_Val:=  6.0; (*mm*)
      sAdsSheetAlignment  [lCtr].sI_HeadGap.fI_Val       :=  1.3; (*mm*)

//      Fb_PaperP_Detect_Cam[lCtr].iI_CurrentTimeStampComp := 2_000;
//      Fb_PaperP_Detect_Cam[lCtr].iI_SensorTimeStampComp  := 150;

    END_FOR;

    sAdsPrintGroup[ePr_PG_GROUP_1].sI_ShiftPositionX.lI_Val   := 100_000; (*um*)
    sAdsPrintGroup[ePr_PG_GROUP_2].sI_ShiftPositionX.lI_Val   := 200_000; (*um*)
    sAdsPrintGroup[ePr_PG_GROUP_3].sI_ShiftPositionX.lI_Val   := 300_000; (*um*)
    sAdsPrintGroup[ePr_PG_GROUP_4].sI_ShiftPositionX.lI_Val   := 400_000; (*um*)

    (*--- PC ---*)
    FOR lCtr := 1 TO iCPr_NB_PC DO
      sAdsPrintController[lCtr].sI_EnableHeater.bI_SetBool := TRUE;
      sAdsPrintController[lCtr].sI_EnablePrint .bI_SetBool := TRUE;
    END_FOR;

    (*--- PH ---*)
    FOR lCtr := 1 TO iCPr_NB_PH DO
      sAdsPrintHead[lCtr].aI_MaskFileName               := 'mask.msk';
      sAdsPrintHead[lCtr].aI_WaveFileName               := 'waveform.wav';
      sAdsPrintHead[lCtr].sI_VoltageScale.fI_Val        := 100;
    END_FOR;

    (*Recipe: write last recipe values*)
    IF pFbRecipeMngr <> 0 THEN
      pFbRecipeMngr^.mWriteRecipe(aSubName:='');
      PRG_MACHINE.bI_RecipeValuesLoadedPrint := TRUE;
    END_IF;

  ELSE

    (*--- PU ---*)
    FOR lCtr := 1 TO iCPr_NB_PU DO
      sAdsPrintUnit[lCtr].bI_Enable                     := sR_RemVar_P.bL_sAdsPrintUnit_bI_Enable[lCtr];

      sAdsPrintUnit[lCtr].sI_ShiftJobX.lI_Val           := sR_RemVar_P.lL_sAdsPrintUnit_sI_ShiftJobX[lCtr];
      sAdsPrintUnit[lCtr].sI_ShiftJobY.lI_Val           := sR_RemVar_P.lL_sAdsPrintUnit_sI_ShiftJobY[lCtr];

      sAdsSheetAlignment[lCtr].bI_UsePrintMark          := sR_RemVar_P.bL_WithMark;
      sAdsSheetAlignment[lCtr].sI_PrintMarkSizeX.fI_Val := sR_RemVar_P.fL_MarkLength;
      sAdsSheetAlignment[lCtr].sI_PrintMarkSizeY.fI_Val := sR_RemVar_P.fL_MarkHeigth;
    END_FOR;



    (*--- PG ---*)
    FOR lCtr := 1 TO iCPr_NB_PG DO
      sAdsPrintGroup [lCtr].bI_Enable                   := sR_RemVar_P.rL_sAdsPrintGroup_bI_Enable        [lCtr];
      sAdsPrintGroup [lCtr].sI_ShiftPositionX.lI_Val    := sR_RemVar_P.rL_sAdsPrintGroup_iO_PositionX     [lCtr];
      sAdsPrintGroup [lCtr].sI_ShiftPositionY.lI_Val    := sR_RemVar_P.rL_sAdsPrintGroup_iO_StartPositionX[lCtr];
    END_FOR;

    (*--- PC ---*)
    FOR lCtr := 1 TO iCPr_NB_PC DO
      sAdsPrintController[lCtr].bI_Enable                  := sR_RemVar_P.rL_sAdsPrintController      [lCtr];
      sAdsPrintController[lCtr].sI_EnableHeater.bI_SetBool := sR_RemVar_P.rL_sAdsPrintControllerHeater[lCtr];
      sAdsPrintController[lCtr].sI_EnablePrint .bI_SetBool := sR_RemVar_P.rL_sAdsPrintControllerPrint [lCtr];
    END_FOR;

    (*--- PH ---*)
    FOR lCtr := 1 TO iCPr_NB_PH DO
      sAdsPrintHead[lCtr].bI_Enable                     := sR_RemVar_P.rL_sAdsPrintHead_bI_Enable        [lCtr];
      sAdsPrintHead[lCtr].sI_ShiftPositionX.lI_Val      := sR_RemVar_P.rL_sAdsPrintHead_iO_PositionX     [lCtr];
      sAdsPrintHead[lCtr].sI_PositionX.lI_Val           := sR_RemVar_P.rL_sAdsPrintHead_iO_StartPositionX[lCtr];
      sAdsPrintHead[lCtr].sI_PositionY.lI_Val           := sR_RemVar_P.rL_sAdsPrintHead_iO_StartPositionY[lCtr];
      sAdsPrintHead[lCtr].aI_MaskFileName               := sR_RemVar_P.rL_sAdsPrintHead_aI_MaskFileName  [lCtr];
      sAdsPrintHead[lCtr].aI_WaveFileName               := sR_RemVar_P.rL_sAdsPrintHead_aI_WaveFileName  [lCtr];
      sAdsPrintHead[lCtr].sI_VoltageScale.fI_Val        := sR_RemVar_P.rL_sAdsPrintHead_fI_VoltScale     [lCtr];
    END_FOR;

  END_IF;

(*************************************************************************************************)
(********************************* WRITING REMANENT VARIABLES ************************************)
(*************************************************************************************************)
ELSE
  (* ------ Update Remanent values --------- *)

  (*--- PU ---*)
  FOR lCtr:=1 TO iCPr_NB_PU DO
    sR_RemVar_P.bL_sAdsPrintUnit_bI_Enable[lCtr]          := sAdsPrintUnit[lCtr].bI_Enable;

    sR_RemVar_P.lL_sAdsPrintUnit_sI_ShiftJobX[lCtr]       := sAdsPrintUnit[lCtr].sI_ShiftJobX.lI_Val;
    sR_RemVar_P.lL_sAdsPrintUnit_sI_ShiftJobY[lCtr]       := sAdsPrintUnit[lCtr].sI_ShiftJobY.lI_Val;


    sR_RemVar_P.bL_WithMark                               := sAdsSheetAlignment[lCtr].bI_UsePrintMark;
    sR_RemVar_P.fL_MarkLength                             := sAdsSheetAlignment[lCtr].sI_PrintMarkSizeX.fI_Val;
    sR_RemVar_P.fL_MarkHeigth                             := sAdsSheetAlignment[lCtr].sI_PrintMarkSizeY.fI_Val;

  END_FOR;

  (*--- PG ---*)
  FOR lCtr:=1 TO iCPr_NB_PG DO
    sR_RemVar_P.rL_sAdsPrintGroup_bI_Enable        [lCtr] := sAdsPrintGroup [lCtr].bI_Enable;
    sR_RemVar_P.rL_sAdsPrintGroup_iO_PositionX     [lCtr] := sAdsPrintGroup [lCtr].sI_ShiftPositionX.lI_Val;
    sR_RemVar_P.rL_sAdsPrintGroup_iO_StartPositionX[lCtr] := sAdsPrintGroup [lCtr].sI_ShiftPositionY.lI_Val;
  END_FOR;

  (*--- PC ---*)
  FOR lCtr:=1 TO iCPr_NB_PC DO
    sR_RemVar_P.rL_sAdsPrintController             [lCtr] := sAdsPrintController[lCtr].bI_Enable;
    sR_RemVar_P.rL_sAdsPrintControllerHeater       [lCtr] := sAdsPrintController[lCtr].sI_EnableHeater.bI_SetBool;
    sR_RemVar_P.rL_sAdsPrintControllerPrint        [lCtr] := sAdsPrintController[lCtr].sI_EnablePrint .bI_SetBool;
  END_FOR;

  (*--- PH ---*)
  FOR lCtr:=1 TO iCPr_NB_PH DO
    sR_RemVar_P.rL_sAdsPrintHead_bI_Enable         [lCtr] := sAdsPrintHead[lCtr].bI_Enable;
    sR_RemVar_P.rL_sAdsPrintHead_iO_PositionX      [lCtr] := sAdsPrintHead[lCtr].sI_ShiftPositionX.lI_Val;
    sR_RemVar_P.rL_sAdsPrintHead_iO_StartPositionX [lCtr] := sAdsPrintHead[lCtr].sI_PositionX.lI_Val;
    sR_RemVar_P.rL_sAdsPrintHead_iO_StartPositionY [lCtr] := sAdsPrintHead[lCtr].sI_PositionY.lI_Val;
    sR_RemVar_P.rL_sAdsPrintHead_aI_MaskFileName   [lCtr] := sAdsPrintHead[lCtr].aI_MaskFileName;
    sR_RemVar_P.rL_sAdsPrintHead_aI_WaveFileName   [lCtr] := sAdsPrintHead[lCtr].aI_WaveFileName;
    sR_RemVar_P.rL_sAdsPrintHead_fI_VoltScale      [lCtr] := sAdsPrintHead[lCtr].sI_VoltageScale.fI_Val;
  END_FOR;

END_IF;]]></ST>
      </Implementation>
    </Method>
    <Method Name="setLoggingLevels" Id="{b5314210-0a83-45c7-8762-438698f868bb}">
      <Declaration><![CDATA[METHOD PRIVATE setLoggingLevels
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[(*Configure logging*)
LogPrSetup.LogLevel                  := ePrint_LogLevel;
FB_PU[ePr_PU_UNIT_1].LogLevel        := ePrint_LogLevel;
fBCTManagerMain.LogLevel := E_LogSeverity.Info;
fbWorkerWeu[ePr_PG_GROUP_1].LogLevel := E_LogSeverity.Debug;
fbWorkerWeu[ePr_PG_GROUP_2].LogLevel := E_LogSeverity.Debug;
fbWorkerWeu[ePr_PG_GROUP_3].LogLevel := E_LogSeverity.Debug;
fbWorkerWeu[ePr_PG_GROUP_4].LogLevel := E_LogSeverity.Debug;]]></ST>
      </Implementation>
    </Method>
    <Method Name="setupAdsPc" Id="{d0e6d224-b679-461c-962b-262e0b7468ef}" FolderPath="AdsSetup\">
      <Declaration><![CDATA[METHOD PRIVATE setupAdsPc
VAR_INPUT
  pAds : POINTER TO ST_ADS_PC;
  nIdx : UDINT;
END_VAR

]]></Declaration>
      <Implementation>
        <ST><![CDATA[pAds^.aO_Name 							        := sC_Config_P.aC_PC_NAME[nIdx];
//pAds^.bI_Enable                     := TRUE;   // use persistence
pAds^.bO_EnableExist                := TRUE;
pAds^.sI_EnableHeater.bC_BoolExist  := TRUE;
pAds^.sI_EnableHeater.bO_BoolCanSet := TRUE;
pAds^.sI_EnablePrint .bC_BoolExist  := TRUE;
pAds^.sI_EnablePrint .bO_BoolCanSet := TRUE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="setupAdsPg" Id="{736208b2-1b62-4b6b-a11d-25df08eeacc1}" FolderPath="AdsSetup\">
      <Declaration><![CDATA[METHOD PRIVATE setupAdsPg
VAR_INPUT
  pAds : POINTER TO ST_ADS_PG;
  nIdx : UDINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[pAds^.aO_Name:=sC_Config_P.aC_PG_NAME[nIdx];
pAds^.sI_ShiftPositionX.bC_Exist:=TRUE;
pAds^.sI_ShiftPositionX.aC_Unit:=sC_Config_P.aC_xx_STARTPOS_X_UNIT;
pAds^.sI_ShiftPositionX.lC_Min:=sC_Config_P.lL_xx_STARTPOS_X_SET_MIN;
pAds^.sI_ShiftPositionX.lC_Max:=sC_Config_P.lL_xx_STARTPOS_X_SET_MAX;
pAds^.sI_ShiftPositionY.bC_Exist:=FALSE;
pAds^.sI_ShiftPositionY.aC_Unit:=sC_Config_P.aC_xx_STARTPOS_Y_UNIT;
pAds^.sI_ShiftPositionY.lC_Min:=sC_Config_P.lL_xx_STARTPOS_Y_SET_MIN;
pAds^.sI_ShiftPositionY.lC_Max:=sC_Config_P.lL_xx_STARTPOS_Y_SET_MAX;
pAds^.sI_CommandChangeInk.bO_CommandExist:=FALSE;
pAds^.sI_CommandChangeInk.bO_CommandCanEx:=FALSE;
pAds^.sI_CommandEmptyInk.bO_CommandExist:=FALSE;
pAds^.sI_CommandEmptyInk.bO_CommandCanEx:=FALSE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="setupAdsPh" Id="{d6474a08-4f11-4fea-9fd4-508c47c4b4ba}" FolderPath="AdsSetup\">
      <Declaration><![CDATA[METHOD PRIVATE setupAdsPh
VAR_INPUT
  pAds : POINTER TO ST_ADS_PH;
  nIdx : UDINT;
END_VAR

]]></Declaration>
      <Implementation>
        <ST><![CDATA[pAds^.aO_Name 										:= sC_Config_P.aC_PH_NAME[nIdx];
pAds^.sI_PositionX.bC_Exist       := TRUE;
pAds^.sI_PositionX.aC_Type        := sC_Config_P.aC_xx_POSITION_X_TYPE;
pAds^.sI_PositionX.aC_Unit        := sC_Config_P.aC_xx_POSITION_X_UNIT;
pAds^.sI_PositionX.lC_Min         := sC_Config_P.lL_xx_POSITION_X_SET_MIN;
pAds^.sI_PositionX.lC_Max         := sC_Config_P.lL_xx_POSITION_X_SET_MAX;
pAds^.sI_PositionY.bC_Exist       := TRUE;
pAds^.sI_PositionY.aC_Type        := sC_Config_P.aC_xx_POSITION_X_TYPE;
pAds^.sI_PositionY.aC_Unit        := sC_Config_P.aC_PH_OFFSETPOS_Y_UNIT;
pAds^.sI_PositionY.lC_Min         := sC_Config_P.lL_PH_OFFSETPOS_Y_SET_MIN;
pAds^.sI_PositionY.lC_Max         := sC_Config_P.lL_PH_OFFSETPOS_Y_SET_MAX;
pAds^.sI_ShiftPositionX.bC_Exist  := FALSE;
pAds^.sI_ShiftPositionX.lC_Min    := sC_Config_P.lL_xx_POSITION_X_SET_MIN;
pAds^.sI_ShiftPositionX.lC_Max    := sC_Config_P.lL_xx_POSITION_X_SET_MAX;
pAds^.sI_ShiftPositionY.bC_Exist  := FALSE;
pAds^.sI_ShiftPositionY.lC_Min    := sC_Config_P.lL_PH_OFFSETPOS_Y_SET_MIN;
pAds^.sI_ShiftPositionY.lC_Max    := sC_Config_P.lL_PH_OFFSETPOS_Y_SET_MAX;
pAds^.sI_VoltageScale.bC_Exist    := TRUE;
pAds^.sI_VoltageScale.aC_Unit     := '%';
pAds^.sI_VoltageScale.fC_Min      := 90;
pAds^.sI_VoltageScale.fC_Max      := 110;
pAds^.cO_HeadIndex                := cCPr_MAP_PH_PC_INDEX[lCtr];]]></ST>
      </Implementation>
    </Method>
    <Method Name="setupAdsPm" Id="{606d63d6-e007-4b24-aa3f-3111b08f8d0e}" FolderPath="AdsSetup\">
      <Declaration><![CDATA[METHOD PRIVATE setupAdsPm
VAR_INPUT
  pAds : POINTER TO ST_ADS_PM;
  nIdx : UDINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[pAds^.aO_Name                     := sC_Config_P.aC_PM_NAME[nIdx];
pAds^.bI_Enable                   := TRUE;
pAds^.sI_GeneralShiftX.bC_Exist   := TRUE;
pAds^.sI_GeneralShiftX.aC_Unit    := sC_Config_P.aC_PU_GENERALSHIFT_X_UNIT;
pAds^.sI_GeneralShiftX.lC_Min     := sC_Config_P.lL_PU_GENERALSHIFT_X_SET_MIN;
pAds^.sI_GeneralShiftX.lC_Max     := sC_Config_P.lL_PU_GENERALSHIFT_X_SET_MAX;
pAds^.sI_GeneralShiftY.bC_Exist   := TRUE;
pAds^.sI_GeneralShiftY.aC_Unit    := sC_Config_P.aC_PU_GENERALSHIFT_Y_UNIT;
pAds^.sI_GeneralShiftY.lC_Min     := sC_Config_P.lL_PU_GENERALSHIFT_Y_SET_MIN;
pAds^.sI_GeneralShiftY.lC_Max     := sC_Config_P.lL_PU_GENERALSHIFT_Y_SET_MAX;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="setupAdsPu" Id="{81f2ac49-1b09-4a27-a2a5-f99724c73587}" FolderPath="AdsSetup\">
      <Declaration><![CDATA[METHOD PRIVATE setupAdsPu
VAR_INPUT
  pAds : POINTER TO ST_ADS_PU;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[pAds^.aO_Name 										     := sC_Config_P.aC_PU_NAME[nCtr];;
pAds^.sI_ShiftJobX.bC_Exist            := FALSE;
pAds^.sI_ShiftJobX.aC_Unit             := sC_Config_P.aC_PU_SHIFTPOS_X_UNIT;
pAds^.sI_ShiftJobX.lC_Min              := sC_Config_P.lL_PU_SHIFTPOS_X_SET_MIN;
pAds^.sI_ShiftJobX.lC_Max              := sC_Config_P.lL_PU_SHIFTPOS_X_SET_MAX;
pAds^.sI_ShiftJobY.bC_Exist            := FALSE;
pAds^.sI_ShiftJobY.aC_Unit             := sC_Config_P.aC_PU_SHIFTPOS_Y_UNIT;
pAds^.sI_ShiftJobY.lC_Min              := sC_Config_P.lL_PU_SHIFTPOS_Y_SET_MIN;
pAds^.sI_ShiftJobY.lC_Max              := sC_Config_P.lL_PU_SHIFTPOS_Y_SET_MAX;
pAds^.sO_StopRequestEvent.bC_Enable    := TRUE;
pAds^.sO_StopRequestEvent.bC_Exist     := TRUE;
pAds^.sO_StopRequestEvent.iC_CycleTime := 50;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="setupAdsSa" Id="{b2153208-6ced-40ee-9c6b-b542d0bafcfc}" FolderPath="AdsSetup\">
      <Declaration><![CDATA[METHOD PRIVATE setupAdsSa
VAR_INPUT
  pAds : POINTER TO ST_ADS_DVTSHEETALIGNMENT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[pAds^.aO_Name                    := sC_Config_P.aC_SHEETALIGNMENT_NAME;
pAds^.sI_PrintMarkSizeX.bC_Exist := TRUE;
pAds^.sI_PrintMarkSizeX.aC_Unit  := sC_Config_P.aC_xx_PRINTMARK_X_UNIT;
pAds^.sI_PrintMarkSizeX.fC_Min   := sC_Config_P.fL_xx_PRINTMARK_X_SET_MIN;
pAds^.sI_PrintMarkSizeX.fC_Max   := sC_Config_P.fL_xx_PRINTMARK_X_SET_MAX;
pAds^.sI_PrintMarkSizeY.bC_Exist := TRUE;
pAds^.sI_PrintMarkSizeY.aC_Unit  := sC_Config_P.aC_xx_PRINTMARK_Y_UNIT;
pAds^.sI_PrintMarkSizeY.fC_Min   := sC_Config_P.fL_xx_PRINTMARK_Y_SET_MIN;
pAds^.sI_PrintMarkSizeY.fC_Max   := sC_Config_P.fL_xx_PRINTMARK_Y_SET_MAX;
pAds^.sI_HeadGap.bC_Exist        := TRUE;
pAds^.sI_HeadGap.aC_Unit         := sC_Config_P.aC_xx_HEAD_GAP_UNIT;
pAds^.sI_HeadGap.fC_Min          := sC_Config_P.fL_xx_HEAD_GAP_SET_MIN;
pAds^.sI_HeadGap.fC_Max          := sC_Config_P.fL_xx_HEAD_GAP_SET_MAX;
pAds^.sO_CurrentAngle.bC_Exist   := FALSE;
pAds^.sO_CurrentAngle.aC_Unit    := sC_Config_P.aC_xx_CURRENT_ANGLE_UNIT;
pAds^.sO_CurrentAngle.fC_Min     := sC_Config_P.fL_xx_CURRENT_ANGLE_SET_MIN;
pAds^.sO_CurrentAngle.fC_Max     := sC_Config_P.fL_xx_CURRENT_ANGLE_SET_MAX;]]></ST>
      </Implementation>
    </Method>
    <Method Name="setupAdsSub" Id="{d1763db5-8750-4245-bd17-87a4374eeeae}" FolderPath="AdsSetup\">
      <Declaration><![CDATA[METHOD PRIVATE setupAdsSub
VAR_INPUT
  pAds : POINTER TO ST_ADS_SUBSTRATE;
  nIdx : UDINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[pAds^.aO_Name                     := CONCAT(sC_Config_P.aC_SUB_NAME, TO_STRING(nInx));
pAds^.sI_SurfaceVelocity.bC_Exist := FALSE;
pAds^.sI_SurfaceVelocity.aC_Type  := sC_Config_P.aC_SUB_SURFACE_VELOCITY_TYPE;
pAds^.sI_SurfaceVelocity.aC_Unit  := sC_Config_P.aC_SUB_SURFACE_VELOCITY_UNIT;
pAds^.sI_SurfaceVelocity.fC_Min   := sC_Config_P.fC_SUB_SURFACE_VELOCITY_SET_MIN;
pAds^.sI_SurfaceVelocity.fC_Max   := sC_Config_P.fC_SUB_SURFACE_VELOCITY_SET_MAX;
pAds^.sI_SizeX.bC_Exist           := FALSE;
pAds^.sI_SizeX.aC_Unit            := sC_Config_P.aC_SUB_SURFACE_SIZE_UNIT;
pAds^.sI_SizeX.fC_Min             := sC_Config_P.fC_SUB_SURFACE_SIZE_SET_MIN;
pAds^.sI_SizeX.fC_Max             := sC_Config_P.fC_SUB_SURFACE_SIZE_SET_MAX;
pAds^.sI_SizeY.bC_Exist           := FALSE;
pAds^.sI_SizeY.aC_Unit            := sC_Config_P.aC_SUB_SURFACE_SIZE_UNIT;
pAds^.sI_SizeY.fC_Min             := sC_Config_P.fC_SUB_SURFACE_SIZE_SET_MIN;
pAds^.sI_SizeY.fC_Max             := sC_Config_P.fC_SUB_SURFACE_SIZE_SET_MAX;
pAds^.sI_SizeZ.bC_Exist           := FALSE;
pAds^.sI_SizeZ.aC_Unit            := sC_Config_P.aC_SUB_SURFACE_SIZE_UNIT;
pAds^.sI_SizeZ.fC_Min             := sC_Config_P.fC_SUB_SURFACE_SIZE_SET_MIN;
pAds^.sI_SizeZ.fC_Max             := sC_Config_P.fC_SUB_SURFACE_SIZE_SET_MAX;
pAds^.sI_PositionX.bC_Exist       := FALSE;
pAds^.sI_PositionX.aC_Unit        := sC_Config_P.aC_SUB_SURFACE_POS_UNIT;
pAds^.sI_PositionX.fC_Min         := sC_Config_P.fC_SUB_SURFACE_POS_SET_MIN;
pAds^.sI_PositionX.fC_Max         := sC_Config_P.fC_SUB_SURFACE_POS_SET_MAX;
pAds^.sI_PositionY.bC_Exist       := FALSE;
pAds^.sI_PositionY.aC_Unit        := sC_Config_P.aC_SUB_SURFACE_POS_UNIT;
pAds^.sI_PositionY.fC_Min         := sC_Config_P.fC_SUB_SURFACE_POS_SET_MIN;
pAds^.sI_PositionY.fC_Max         := sC_Config_P.fC_SUB_SURFACE_POS_SET_MAX;
pAds^.sI_PositionZ.bC_Exist       := FALSE;
pAds^.sI_PositionZ.aC_Unit        := sC_Config_P.aC_SUB_SURFACE_POS_UNIT;
pAds^.sI_PositionZ.fC_Min         := sC_Config_P.fC_SUB_SURFACE_POS_SET_MIN;
pAds^.sI_PositionZ.fC_Max         := sC_Config_P.fC_SUB_SURFACE_POS_SET_MAX;]]></ST>
      </Implementation>
    </Method>
    <Method Name="Testing" Id="{1556e5de-05b1-4cc9-99a3-a90b95b77a8c}">
      <Declaration><![CDATA[METHOD Testing : BOOL
VAR_INPUT
END_VAR
VAR
  nCt, nRun : DINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF NOT fbPrgPrintTest.bInitialized THEN fbPrgPrintTest.Init(pAdsPu := ADR(sAdsPrintUnit[1])); END_IF
fbPrgPrintTest();

// testing 
(*
FOR iL_I:=1 TO iCPr_NB_PM DO
  //TEST: CT creation
  fbCtCreateTrigger(CLK := bCreateTrig);
  bCreateTrig := FALSE;
  IF fbCtCreateTrigger.RT THEN //Passt nicht, muss beim CreateCT beim Beladen
    iCT := fBCTManager[iL_I].CreateCT(); //<==Call this when a new workpiece has been loaded, destroyCT?
  END_IF
  
  //TEST: CT destroy
  fbCtDestroyTrigger(CLK := bDestroyTrig);
  bDestroyTrig := FALSE;
  IF fbCtDestroyTrigger.RT THEN //Passt nicht, muss beim DestroyCT beim Entladen
    fBCTManager[iL_I].DestroyCT(iCT := fBCTManager[iL_I].getCT(nIdx := 1));
  END_IF
END_FOR
*)

// call project test program
PRG_TEST();]]></ST>
      </Implementation>
    </Method>
    <Action Name="Visu" Id="{f68d4b28-cf7f-4a25-9134-ca48d2d9ccb8}">
      <Implementation>
        <ST><![CDATA[(*call visu controls*)
fb_visu_pu      (sI_Ary_Fb      := FB_PU, sI_Ary_Ads := sAdsPrintUnit);
fb_visu_pc      (sI_Ary_Fb      := FB_PC, sI_Ary_Ads := sAdsPrintController);
fb_visu_ph      (sI_Ary_Fb      := FB_PH);

fbRTrigMarkSelectNormal();   IF fbRTrigMarkSelectNormal.Q   THEN bMarksInverted := FALSE; END_IF
fbRTrigMarkSelectInverted(); IF fbRTrigMarkSelectInverted.Q THEN bMarksInverted := TRUE;  END_IF]]></ST>
      </Implementation>
    </Action>
    <LineIds Name="PRG_PRINT">
      <LineId Id="74005" Count="39" />
      <LineId Id="75168" Count="0" />
      <LineId Id="75167" Count="0" />
      <LineId Id="75455" Count="0" />
      <LineId Id="75460" Count="0" />
      <LineId Id="75169" Count="0" />
      <LineId Id="75176" Count="1" />
      <LineId Id="75181" Count="0" />
      <LineId Id="75184" Count="1" />
      <LineId Id="75191" Count="0" />
      <LineId Id="75170" Count="0" />
      <LineId Id="74045" Count="3" />
      <LineId Id="74629" Count="0" />
      <LineId Id="74904" Count="3" />
      <LineId Id="74911" Count="2" />
      <LineId Id="74909" Count="1" />
      <LineId Id="74908" Count="0" />
      <LineId Id="74089" Count="13" />
      <LineId Id="75461" Count="0" />
      <LineId Id="74103" Count="16" />
      <LineId Id="74121" Count="24" />
      <LineId Id="74608" Count="2" />
      <LineId Id="74146" Count="0" />
      <LineId Id="74624" Count="0" />
      <LineId Id="74623" Count="0" />
      <LineId Id="74613" Count="0" />
      <LineId Id="74627" Count="0" />
      <LineId Id="74614" Count="0" />
      <LineId Id="74616" Count="0" />
      <LineId Id="74618" Count="2" />
      <LineId Id="74617" Count="0" />
      <LineId Id="74621" Count="0" />
      <LineId Id="74147" Count="0" />
      <LineId Id="74626" Count="0" />
      <LineId Id="74622" Count="0" />
      <LineId Id="74198" Count="5" />
      <LineId Id="74205" Count="12" />
      <LineId Id="74223" Count="11" />
      <LineId Id="74649" Count="1" />
      <LineId Id="74648" Count="0" />
      <LineId Id="75456" Count="0" />
      <LineId Id="75445" Count="0" />
      <LineId Id="75447" Count="1" />
      <LineId Id="75451" Count="1" />
      <LineId Id="75450" Count="0" />
      <LineId Id="75446" Count="0" />
      <LineId Id="74317" Count="39" />
      <LineId Id="45822" Count="0" />
    </LineIds>
    <LineIds Name="PRG_PRINT.Control">
      <LineId Id="99" Count="3" />
      <LineId Id="98" Count="0" />
      <LineId Id="121" Count="0" />
      <LineId Id="104" Count="1" />
      <LineId Id="126" Count="0" />
      <LineId Id="106" Count="0" />
      <LineId Id="110" Count="1" />
      <LineId Id="113" Count="1" />
      <LineId Id="116" Count="0" />
      <LineId Id="127" Count="0" />
      <LineId Id="117" Count="3" />
      <LineId Id="96" Count="0" />
      <LineId Id="123" Count="0" />
      <LineId Id="97" Count="0" />
      <LineId Id="125" Count="0" />
      <LineId Id="124" Count="0" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="PRG_PRINT.DownloadFiles">
      <LineId Id="6" Count="3" />
      <LineId Id="11" Count="31" />
      <LineId Id="60" Count="0" />
      <LineId Id="43" Count="0" />
      <LineId Id="56" Count="0" />
      <LineId Id="44" Count="7" />
      <LineId Id="62" Count="0" />
      <LineId Id="61" Count="0" />
      <LineId Id="63" Count="2" />
      <LineId Id="52" Count="1" />
      <LineId Id="69" Count="25" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="PRG_PRINT.init">
      <LineId Id="1329" Count="31" />
      <LineId Id="1374" Count="8" />
      <LineId Id="1954" Count="1" />
      <LineId Id="1383" Count="0" />
      <LineId Id="1956" Count="0" />
      <LineId Id="1384" Count="0" />
      <LineId Id="1792" Count="0" />
      <LineId Id="1385" Count="2" />
      <LineId Id="1389" Count="2" />
      <LineId Id="1436" Count="0" />
      <LineId Id="1444" Count="2" />
      <LineId Id="1957" Count="1" />
      <LineId Id="1451" Count="1" />
      <LineId Id="1824" Count="0" />
      <LineId Id="1951" Count="0" />
      <LineId Id="1825" Count="0" />
      <LineId Id="1907" Count="0" />
      <LineId Id="2034" Count="0" />
      <LineId Id="1908" Count="1" />
      <LineId Id="2003" Count="0" />
      <LineId Id="2041" Count="0" />
      <LineId Id="1905" Count="0" />
      <LineId Id="1949" Count="0" />
      <LineId Id="2006" Count="0" />
      <LineId Id="1494" Count="0" />
      <LineId Id="2008" Count="1" />
      <LineId Id="2013" Count="7" />
      <LineId Id="2010" Count="2" />
      <LineId Id="1496" Count="0" />
      <LineId Id="2021" Count="0" />
      <LineId Id="1497" Count="0" />
      <LineId Id="1517" Count="12" />
      <LineId Id="2040" Count="0" />
      <LineId Id="1530" Count="7" />
      <LineId Id="1547" Count="0" />
      <LineId Id="1896" Count="0" />
      <LineId Id="2069" Count="0" />
      <LineId Id="1548" Count="5" />
      <LineId Id="1582" Count="8" />
      <LineId Id="2070" Count="1" />
      <LineId Id="1591" Count="2" />
      <LineId Id="1995" Count="1" />
      <LineId Id="1960" Count="0" />
      <LineId Id="1631" Count="10" />
      <LineId Id="1643" Count="0" />
      <LineId Id="1645" Count="1" />
      <LineId Id="2049" Count="0" />
      <LineId Id="2054" Count="8" />
      <LineId Id="2052" Count="1" />
      <LineId Id="1665" Count="6" />
      <LineId Id="1678" Count="0" />
      <LineId Id="2072" Count="1" />
      <LineId Id="1679" Count="3" />
      <LineId Id="1684" Count="87" />
      <LineId Id="1863" Count="0" />
      <LineId Id="1862" Count="0" />
      <LineId Id="1772" Count="0" />
      <LineId Id="1887" Count="2" />
      <LineId Id="1773" Count="12" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="PRG_PRINT.Mapping">
      <LineId Id="185" Count="8" />
      <LineId Id="326" Count="0" />
      <LineId Id="195" Count="2" />
      <LineId Id="201" Count="5" />
      <LineId Id="331" Count="3" />
      <LineId Id="337" Count="0" />
      <LineId Id="339" Count="0" />
      <LineId Id="335" Count="1" />
      <LineId Id="207" Count="13" />
      <LineId Id="225" Count="0" />
      <LineId Id="314" Count="1" />
      <LineId Id="226" Count="0" />
      <LineId Id="317" Count="0" />
      <LineId Id="316" Count="0" />
      <LineId Id="228" Count="2" />
      <LineId Id="289" Count="0" />
      <LineId Id="298" Count="0" />
      <LineId Id="297" Count="0" />
      <LineId Id="299" Count="0" />
      <LineId Id="340" Count="0" />
      <LineId Id="306" Count="1" />
      <LineId Id="311" Count="0" />
      <LineId Id="308" Count="1" />
      <LineId Id="324" Count="0" />
      <LineId Id="288" Count="0" />
      <LineId Id="313" Count="0" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="PRG_PRINT.RemVar">
      <LineId Id="6" Count="22" />
      <LineId Id="32" Count="42" />
      <LineId Id="79" Count="3" />
      <LineId Id="84" Count="1" />
      <LineId Id="89" Count="40" />
      <LineId Id="134" Count="6" />
      <LineId Id="146" Count="25" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="PRG_PRINT.setLoggingLevels">
      <LineId Id="6" Count="6" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="PRG_PRINT.setupAdsPc">
      <LineId Id="10" Count="5" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="PRG_PRINT.setupAdsPg">
      <LineId Id="76" Count="11" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="PRG_PRINT.setupAdsPh">
      <LineId Id="23" Count="0" />
      <LineId Id="25" Count="4" />
      <LineId Id="31" Count="4" />
      <LineId Id="37" Count="2" />
      <LineId Id="41" Count="2" />
      <LineId Id="45" Count="3" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="PRG_PRINT.setupAdsPm">
      <LineId Id="26" Count="9" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="PRG_PRINT.setupAdsPu">
      <LineId Id="21" Count="0" />
      <LineId Id="7" Count="3" />
      <LineId Id="12" Count="3" />
      <LineId Id="17" Count="2" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="PRG_PRINT.setupAdsSa">
      <LineId Id="29" Count="0" />
      <LineId Id="8" Count="3" />
      <LineId Id="13" Count="3" />
      <LineId Id="18" Count="3" />
      <LineId Id="23" Count="2" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="PRG_PRINT.setupAdsSub">
      <LineId Id="34" Count="0" />
      <LineId Id="39" Count="4" />
      <LineId Id="45" Count="11" />
      <LineId Id="58" Count="10" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="PRG_PRINT.Testing">
      <LineId Id="22" Count="0" />
      <LineId Id="18" Count="0" />
      <LineId Id="50" Count="0" />
      <LineId Id="45" Count="0" />
      <LineId Id="17" Count="0" />
      <LineId Id="51" Count="0" />
      <LineId Id="28" Count="1" />
      <LineId Id="48" Count="0" />
      <LineId Id="30" Count="5" />
      <LineId Id="49" Count="0" />
      <LineId Id="36" Count="3" />
      <LineId Id="47" Count="0" />
      <LineId Id="46" Count="0" />
      <LineId Id="13" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="PRG_PRINT.Visu">
      <LineId Id="2" Count="0" />
      <LineId Id="4" Count="0" />
      <LineId Id="7" Count="0" />
      <LineId Id="10" Count="0" />
      <LineId Id="9" Count="0" />
      <LineId Id="1" Count="0" />
      <LineId Id="13" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>