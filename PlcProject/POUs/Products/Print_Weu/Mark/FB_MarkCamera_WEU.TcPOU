<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.11">
  <POU Name="FB_MarkCamera_WEU" Id="{022ae170-1450-4de8-9411-2fff24170cee}" SpecialFunc="None">
    <Declaration><![CDATA[(*
  Mark camera system on WEU machine
  1 mark sensor (optional: reverse mode - roll printed in reversed direction, sensor moved to other side)
*)
FUNCTION_BLOCK FB_MarkCamera_WEU EXTENDS FB_CameraBase 
VAR
  // config
  _iMarkDefinition          : I_MarkDefinition;     // link to detection logic (get points, teach points)
  
  // sample & delay of states
  Dly_Ton                       : TON;      // delay timer
  Dly_CamTrigger_Request        : BOOL;     // delayed CamTrigger() call request
  Dly_CamTrigger_bOk            : BOOL;     // delayed CamTrigger() parameter
	Dly_CamTrigger_nPos           : DINT;     // delayed CamTrigger() parameter
  Dly_CamTrigger_nPosDeviation  : DINT;     // delayed CamTrigger() parameter
  // teach info
  _bTeachOk                     : BOOL;
  _nTeachedPoints               : UDINT;
  // delay
  //  time or position
  
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[IF NOT _bInitialized THEN RETURN; END_IF

// The detection work is done in FB_MarkDetection
// This FB just uses(receives) the marks from the external implementation
// - Receives events CamTrigger & CamTriggerDone from MarkDetection
// - Get current marks and send them to the iCameraSink

IF _bSimulate THEN sim_update(); END_IF

Dly_Ton(IN:=Dly_CamTrigger_Request, PT:=T#4MS);  // deleay CamTrigger so CT will be for sure attached CameraWorker and Worker has enought time to see the CameraDone status
IF Dly_Ton.Q THEN Dly_CamTrigger_Request := FALSE;
  SUPER^.CamTrigger(bOk:=Dly_CamTrigger_bOk, nPos:=Dly_CamTrigger_nPos, nPosDeviation:=Dly_CamTrigger_nPosDeviation);
END_IF

IF _bCamTriggerStarted THEN
  sendCamPoints();
END_IF]]></ST>
    </Implementation>
    <Folder Name="I_CameraTriggerDevice" Id="{e2dec33a-897c-4e22-aee9-eb47423f04d4}" />
    <Folder Name="Teaching" Id="{9779439f-9901-4ac8-a24c-59c2e2c44f9c}" />
    <Method Name="CamTrigger" Id="{81474d5d-5e6e-4c16-a459-3afa624802bf}" FolderPath="I_CameraTriggerDevice\">
      <Declaration><![CDATA[METHOD CamTrigger
VAR_INPUT
  bOk             : BOOL;     // trigger is ok
	nPos            : DINT;     // camera triggered position
  nPosDeviation   : DINT;     // camera started deviation
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF NOT _bInitialized THEN RETURN; END_IF

(* 
  delay CamTrigger()
  Needed because in endless mode the Sheet-End is potentially already the next start mark
  and the CameraWorker would miss the CameraDone status (CameraTriggerDone()-->CameraTrigger() within same cycle
*)
Dly_CamTrigger_Request := TRUE;
Dly_CamTrigger_bOk := bOk;
Dly_CamTrigger_nPos := nPos;
Dly_CamTrigger_nPosDeviation := nPosDeviation;
//do after timeout in body: SUPER^.CamTrigger(bOk:=bOk, nPos:=nPos, nPosDeviation:=nPosDeviation);

_bTeachOk := (_iMarkDefinition.nMarks > 0);
_nTeachedPoints := _iMarkDefinition.nMarks;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="CamTriggerDone" Id="{1b47eb14-3697-493b-9422-5ad8294365cf}" FolderPath="I_CameraTriggerDevice\">
      <Declaration><![CDATA[METHOD CamTriggerDone
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF NOT _bInitialized THEN RETURN; END_IF

// stream lasting points to Worker Camera
IF _bCamTriggerStarted THEN
  sendCamPoints();
END_IF

sendBorderPoint();

SUPER^.CamTriggerDone();]]></ST>
      </Implementation>
    </Method>
    <Property Name="eCameraMode" Id="{139b08ce-f2ab-437d-89d4-90989524dcb9}">
      <Declaration><![CDATA[{attribute 'monitoring':='call'}
PROPERTY eCameraMode : E_CameraMode
]]></Declaration>
      <Get Name="Get" Id="{dcc67e1c-1172-4dc0-8760-a7217421172f}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[eCameraMode := _eCameraMode;
IF _eCameraMode = E_CameraMode.Auto THEN
  eCameraMode := E_CameraMode.Live;
END_IF]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="eDeviceType" Id="{4cff99ca-d815-47ed-86bc-fb84d5e4b780}">
      <Declaration><![CDATA[PROPERTY eDeviceType : E_CameraDevice]]></Declaration>
      <Get Name="Get" Id="{8d2ae920-228a-44ba-8a46-8bca4ae49bf1}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[eDeviceType := E_CameraDevice.PrintMark;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="GetCamStatus" Id="{7171f1e1-2bc1-4049-86ae-30de97569022}">
      <Declaration><![CDATA[METHOD GetCamStatus : BOOL
VAR_OUTPUT
  bConnectionOK  : BOOL;    // Camera connected
  bTeachOk       : BOOL;    // Teach successful
  nTeachedPoints : UDINT;   // Teached points for this job
  nScannedPoints : UDINT;   // Scanned points on current sheet
  bCamStarted    : BOOL;    // Camera trigger is active, cam started
  bCamDone       : BOOL;    // Camera finished on last CT
  bErrors        : ARRAY[1..GVL_Camera.nC_NbCamErrors] OF BOOL;  // generic error flag list
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF _iMarkDefinition = 0 THEN RETURN; END_IF

bConnectionOK  := TRUE;
bTeachOk       := _bTeachOk;
nTeachedPoints := _nTeachedPoints;
nScannedPoints := _nRxCamPoints;
bCamStarted    := _bCamTriggerStarted;
bCamDone       := _bCamTriggerDone;

GetCamStatus := bConnectionOK AND bTeachOk;   // camera ready]]></ST>
      </Implementation>
    </Method>
    <Method Name="InitMarkCamera" Id="{0c1aea82-d580-47e9-b922-45dcb8adc4f9}">
      <Declaration><![CDATA[METHOD InitMarkCamera
VAR_INPUT
  nPrintUnitResolution         : UDINT;    (*printhead pixel resolution [dpi]*)
  nPrintUnitSubPx              : UDINT;    (*print unit subPixel resolution [SubPx]*)
  iCameraTrigger               : I_CameraTrigger;
  iMarkDefinition              : I_MarkDefinition;  // mark detection fb
END_VAR
VAR
  bOK : BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[SUPER^.Init( nPrintUnitResolution      := nPrintUnitResolution
           , nPrintUnitSubPx           := nPrintUnitSubPx
           , iCameraTrigger            := iCameraTrigger
           , bUseCameraTrigger         := FALSE
           , bUseCameraTriggerFeedback := FALSE);

IF NOT _bInitialized OR iMarkDefinition = 0 THEN LogError('Init: invalid parameter'); RETURN; END_IF

_iMarkDefinition := iMarkDefinition;

_bInitialized := TRUE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="mJobStart" Id="{98df1aac-712b-40bf-ae2a-5c3a55b04142}">
      <Declaration><![CDATA[METHOD mJobStart : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF eCameraMode <> E_CameraMode.NoCorrection THEN 
  TeachMarks();
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sendBorderPoint" Id="{65937b56-8343-4d7c-8bea-cb313141358d}">
      <Declaration><![CDATA[METHOD PRIVATE sendBorderPoint
VAR
  pMark                     : POINTER TO ST_MarkDefinition;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[pMark := _iMarkDefinition.getMark(nIdx:=-1);
IF pMark <> 0 AND_THEN pMark^.sState.bSet THEN
  // Send Mark (CamPoint) to CameraSink
  stCamPoint.x_ref := F_MeterToSubPixelReal(  fPosMeter:=pMark^.fPosX                                 (*[m]*)
                                            , fResoSubPx:=UDINT_TO_LREAL(_nPrintUnitResolution));     (*Result should be in pixels*)
  stCamPoint.y_ref := F_MeterToSubPixelReal( fPosMeter:=pMark^.fPosX                                  (*[m]*)
                                            , fResoSubPx:=UDINT_TO_LREAL(_nPrintUnitResolution));     (*Result should be in pixels*)
  stCamPoint.dx    := F_MeterToSubPixelReal( fPosMeter:=pMark^.sState.dx                              (*[m]*)
                                            , fResoSubPx:=UDINT_TO_LREAL(_nPrintUnitResolution));     (*Result should be in pixels*)
  stCamPoint.dy    := F_MeterToSubPixelReal( fPosMeter:=pMark^.sState.dy                              (*[m]*)
                                            , fResoSubPx:=UDINT_TO_LREAL(_nPrintUnitResolution));     (*Result should be in pixels*)
  stCamPoint.valid := pMark^.sState.bSet;

  IF _iCameraSink <> 0 THEN
    _iCameraSink.AddCamPoint(sDeformationPoint:=stCamPoint);
  END_IF
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sendCamPoints" Id="{d711b1c2-120f-41dd-b383-e767c9a1e424}">
      <Declaration><![CDATA[METHOD PRIVATE sendCamPoints
VAR
  i : UDINT;
  pMark : POINTER TO ST_MarkDefinition;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[WHILE _nRxCamPoints < _iMarkDefinition.nMarksDetected DO
  
  pMark := _iMarkDefinition.getMark(nIdx:=TO_DINT(_nRxCamPoints+1));
  IF pMark <> 0 THEN
    // Send Mark (CamPoint) to CameraSink
    stCamPoint.x_ref := F_MeterToSubPixelReal(  fPosMeter:=pMark^.fPosX                                 (*[m]*)
                                              , fResoSubPx:=UDINT_TO_LREAL(_nPrintUnitResolution));     (*Result should be in pixels*)
    stCamPoint.y_ref := F_MeterToSubPixelReal( fPosMeter:=pMark^.fPosX                                  (*[m]*)
                                              , fResoSubPx:=UDINT_TO_LREAL(_nPrintUnitResolution));     (*Result should be in pixels*)
    stCamPoint.dx    := F_MeterToSubPixelReal( fPosMeter:=pMark^.sState.dx                              (*[m]*)
                                              , fResoSubPx:=UDINT_TO_LREAL(_nPrintUnitResolution));     (*Result should be in pixels*)
    stCamPoint.dy    := F_MeterToSubPixelReal( fPosMeter:=pMark^.sState.dy                              (*[m]*)
                                              , fResoSubPx:=UDINT_TO_LREAL(_nPrintUnitResolution));     (*Result should be in pixels*)
    stCamPoint.valid := pMark^.sState.bSet;
  
    IF _iCameraSink <> 0 THEN
      _iCameraSink.AddCamPoint(sDeformationPoint:=stCamPoint);
    END_IF
  ELSE
    LogWarning(F_Concat2('Requested mark not found, mark Idx=', TO_STRING(_nRxCamPoints+1)));
  END_IF
  
  _nRxCamPoints := _nRxCamPoints + 1;   // next mark
END_WHILE]]></ST>
      </Implementation>
    </Method>
    <Method Name="setCameraMode" Id="{b544e398-6fa9-48f7-9517-2291b5b5ae0e}">
      <Declaration><![CDATA[(*
  Set mode to camera.
  :return: TRUE if success
*)
METHOD setCameraMode : BOOL
VAR_INPUT
  eCameraMode : E_CameraMode;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF eCameraMode = E_CameraMode.Auto OR
   eCameraMode = E_CameraMode.NoCorrection OR
   eCameraMode = E_CameraMode.Live
   //eCameraMode = E_CameraMode.Trend 
THEN
   
  _eCameraMode := eCameraMode;  // set desired mode
  setCameraMode := TRUE;
ELSE
  LogError(F_Concat3('Camera mode=', TO_STRING(eCameraMode), ' not supported by camera'));
  _eCameraMode := E_CameraMode.NoCorrection;
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="sim_update" Id="{e54e3043-ebe0-4063-a98c-afcbb3fddb7f}">
      <Declaration><![CDATA[METHOD PRIVATE sim_update]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Not implemented]]></ST>
      </Implementation>
    </Method>
    <Property Name="sName" Id="{19c5cb89-f3d7-4de6-8450-7cd468806f5b}">
      <Declaration><![CDATA[{attribute 'monitoring':='variable'}
PROPERTY sName : STRING
]]></Declaration>
      <Get Name="Get" Id="{73270a0c-f7e1-4ad6-9e4c-06f03f404132}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[sName := 'Printmarks';]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="TeachMarks" Id="{bda865f2-b959-47c0-bd1d-61d48f369350}" FolderPath="Teaching\">
      <Declaration><![CDATA[(*
  Calculate marks (position, shape) and register to mark definition. 
*)
METHOD PRIVATE TeachMarks : BOOL
VAR_INPUT
END_VAR
VAR
  i : UDINT;
  spacing : LREAL := 0.08;  // mark spacing
  asq : LREAL := 0.002;     // sqare a length
  atr : LREAL := 0.008;     // triangle length (same h / l)
  numMarks : UDINT;
  xOfs : LREAL := 0.0023;
  yOfs : LREAL := 0.0023;
  
  sNewMark : ST_MarkDefinition;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[

// TODO: this is only a reference caluclation for simulation, please adpat after definition by STAG
//       ...
IF _iMarkDefinition = 0 THEN RETURN; END_IF

_iMarkDefinition.ResetDefinition();

numMarks := TO_UDINT((_fSubstrateLength-2*xOfs) / spacing); //  // TO_UDINT(FLOOR(_fSubstrateLength / spacing);)
IF numMarks = 0 THEN numMarks := 1; END_IF   // at least one mark

// calculate position
FOR i:=1 TO numMarks DO
  sNewMark.fHeight := atr;
  sNewMark.fTrLength := atr;
  sNewMark.fSqLength := SEL(i>1, asq+1.5*atr, asq);
  sNewMark.fPosX := xOfs+(i-1)*spacing;
  sNewMark.fPosY := yOfs;
  sNewMark.bInvertedX := FALSE;
  
  _iMarkDefinition.RegisterMark(sMark:=sNewMark);
END_FOR]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="FB_MarkCamera_WEU">
      <LineId Id="885" Count="5" />
      <LineId Id="948" Count="1" />
      <LineId Id="940" Count="4" />
      <LineId Id="927" Count="0" />
      <LineId Id="926" Count="0" />
      <LineId Id="850" Count="0" />
      <LineId Id="928" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkCamera_WEU.CamTrigger">
      <LineId Id="68" Count="0" />
      <LineId Id="97" Count="0" />
      <LineId Id="78" Count="0" />
      <LineId Id="83" Count="0" />
      <LineId Id="79" Count="1" />
      <LineId Id="82" Count="0" />
      <LineId Id="84" Count="0" />
      <LineId Id="69" Count="0" />
      <LineId Id="86" Count="1" />
      <LineId Id="105" Count="0" />
      <LineId Id="90" Count="0" />
      <LineId Id="89" Count="0" />
      <LineId Id="88" Count="0" />
      <LineId Id="76" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkCamera_WEU.CamTriggerDone">
      <LineId Id="22" Count="0" />
      <LineId Id="39" Count="3" />
      <LineId Id="38" Count="0" />
      <LineId Id="43" Count="0" />
      <LineId Id="32" Count="0" />
      <LineId Id="28" Count="0" />
      <LineId Id="8" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkCamera_WEU.eCameraMode.Get">
      <LineId Id="13" Count="2" />
      <LineId Id="6" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkCamera_WEU.eDeviceType.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkCamera_WEU.GetCamStatus">
      <LineId Id="49" Count="1" />
      <LineId Id="19" Count="0" />
      <LineId Id="11" Count="1" />
      <LineId Id="4" Count="0" />
      <LineId Id="26" Count="0" />
      <LineId Id="39" Count="0" />
      <LineId Id="30" Count="0" />
      <LineId Id="28" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkCamera_WEU.InitMarkCamera">
      <LineId Id="79" Count="4" />
      <LineId Id="78" Count="0" />
      <LineId Id="75" Count="0" />
      <LineId Id="96" Count="0" />
      <LineId Id="95" Count="0" />
      <LineId Id="85" Count="0" />
      <LineId Id="38" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkCamera_WEU.mJobStart">
      <LineId Id="4" Count="0" />
      <LineId Id="6" Count="1" />
    </LineIds>
    <LineIds Name="FB_MarkCamera_WEU.sendBorderPoint">
      <LineId Id="8" Count="15" />
      <LineId Id="26" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkCamera_WEU.sendCamPoints">
      <LineId Id="47" Count="0" />
      <LineId Id="7" Count="16" />
      <LineId Id="41" Count="1" />
      <LineId Id="26" Count="0" />
      <LineId Id="48" Count="0" />
      <LineId Id="39" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkCamera_WEU.setCameraMode">
      <LineId Id="53" Count="2" />
      <LineId Id="24" Count="0" />
      <LineId Id="56" Count="0" />
      <LineId Id="44" Count="0" />
      <LineId Id="26" Count="0" />
      <LineId Id="42" Count="0" />
      <LineId Id="29" Count="0" />
      <LineId Id="43" Count="0" />
      <LineId Id="33" Count="0" />
      <LineId Id="31" Count="0" />
      <LineId Id="22" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkCamera_WEU.sim_update">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkCamera_WEU.sName.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkCamera_WEU.TeachMarks">
      <LineId Id="9" Count="1" />
      <LineId Id="5" Count="0" />
      <LineId Id="11" Count="0" />
      <LineId Id="38" Count="2" />
      <LineId Id="13" Count="0" />
      <LineId Id="12" Count="0" />
      <LineId Id="20" Count="0" />
      <LineId Id="24" Count="0" />
      <LineId Id="23" Count="0" />
      <LineId Id="36" Count="0" />
      <LineId Id="26" Count="0" />
      <LineId Id="29" Count="5" />
      <LineId Id="25" Count="0" />
      <LineId Id="37" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>