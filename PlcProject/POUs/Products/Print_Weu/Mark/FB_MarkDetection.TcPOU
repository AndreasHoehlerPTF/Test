<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.11">
  <POU Name="FB_MarkDetection" Id="{aad86697-3914-473c-b011-68a889a9d234}" SpecialFunc="None">
    <Declaration><![CDATA[(*
  Detects Marks and generates StartTrigger based on one EL1252 timestamp input I/O.
  
  Additionally:
    - returns lateral offset (+/- in [m]) to center of detected marks.
    - manages & supervises mark sequence
    - is a CameraTrigger as well
    - supports simulation mode
  
  NOTE: 
    - a mark has always a rising and falling edge of the sensor (triangle)
    - center position is the middle of the triangular mark

*)
FUNCTION_BLOCK FB_MarkDetection EXTENDS T_NamedBase IMPLEMENTS I_StartPosDetect, I_CameraTrigger, I_Sim
VAR_INPUT
  (*EL1252*)
  bIKp_StartSensor          AT%I* : BOOL;            (*Sensor start trigger*)
  tIKp_TimeStampPos         AT%I* : T_DCTIME64;      (*TimeStamp Pos_Edge @EL1252*)
  tIKn_TimeStampNeg         AT%I* : T_DCTIME64;      (*TimeStamp Neg_Edge @EL1252*)

  // configuration
  bEnable                         : BOOL;            (*Enable start pos detection sensor*)
  bAutomaticMode                  : BOOL;            (*machine is in automatic mode *)
  nCurrentPos                     : DINT;            (*current position in Pulses/Subpixels*)
  fCurrentSpeed                   : LREAL;           (*actual speed of conveyor in [m/s]*)
  
  // Debug & Test
  bManualTrigger                  : BOOL;            // Manual start trigger
  bManualReset                    : BOOL;            // Manaul reset detection
END_VAR
VAR
  bInitOk                         : BOOL;           // fb initialized

  // config
  _fResolution                    : LREAL := 1;     // current used print resolution (dpi*SubPx)
  _pFbMarkDefinition              : POINTER TO FB_MarkDefinition;      // mark definition
  _iCamera                        : I_Camera;       // camera interface
  // settings                                    
  _bUseCameraTrigger              : BOOL;           // (cam specific setting) Generate camera trigger output
  _bUseCameraTriggerFeedback      : BOOL;           // (cam specific setting) Evaluate camera triggered feedback
  _bCamManualTeachMode            : BOOL;           // cam in manual teach mode
  _fSubstrateLength               : LREAL;          // Substrate length in [m]
  _fTriggerDistance               : LREAL;          // Distance between Sensor and Trigger [m]
  _fTriggerLength                 : LREAL := 10;    // Length of trigger signal in ms, min. 3 bus cycles
  _iActiveCam                     : I_CameraTriggerDevice;  // active camera interface (set by Enable() on I_CameraTrigger)

  // sensor
  bSheetActive                    : BOOL;           (*sheet is scanning*)
  bSpeedValid                     : BOOL;           (*speed is valid*)
  bTriggerArmed                   : BOOL;           (*trigger is armed*)
  bCamValid                       : BOOL;           (*camera is valid*)
  
  // helper
  rfT_Enable                      : RF_TRIG;        // edge detection enable
  bResetMethods                   : BOOL;           (*Reset request for checkForMark() internals*)
  isStartMark                     : BOOL;
  isMarkError                     : BOOL;
  nMarkSelection                  : UDINT := 1;     (*Current selected mask to search*)
  pMarkSearch                     : POINTER TO ST_MarkDefinition;
  _fSubstrateLengthEffective      : LREAL;          // Substrate length in [m]
  
  // time calculations
  tNowDc                          : T_DCTIME64;     (* Get Current Timestamp (now)*)
  fCycleTime                      : LREAL;          (*Current calculated cycle time [s]*)
  
  // params
  _bStartTrig                     : BOOL;           // Start Trigger Edge
  _nX0                            : DINT;           // X0 Position [SubPx]
  _bValid                         : BOOL;           //
  
  // simulation & debug
  _bSimEnable                     : BOOL;           // simulation mode enabled
  // view 
  nMarkXMoveScale                 : UDINT := 140;
END_VAR
VAR PERSISTENT
  bR_TerminateLast                : BOOL;           // Terminate sheet with last defined & detected mark
  nR_AreaMarkSensorOk             : INT := 10;      (*Area with the correct arrangement of the mark sensor [%]*)
END_VAR
VAR CONSTANT
  fC_InhibitSubstrateMargin       : LREAL := 0.010;   (*[m] decrease substrate for inhibit in*)
  fC_MinimalSpeed                 : LREAL := 0.010;   //[m/s]
  fC_MarkLengthMargin             : LREAL := 0.005;   // [m]
  fC_MaxSubstrateFactor           : LREAL := 1.025;   // factor which the sheet length can be max. longer
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[// check parameter
IF NOT bInitOk THEN RETURN; END_IF

// General calculations
bSpeedValid   := fCurrentSpeed > fC_MinimalSpeed;                // speed valid (ignore trigger if not moving)
bCamValid     := SEL(_iActiveCam<>0, FALSE, TRUE);                // camera valid (ignore trigger otherwise)
tNowDc        := F_GetCurDcTaskTime64();                         // current dc time (most accurate time stamp we have)
fCycleTime    := calcCycleTime(tCurrent:=tNowDc);                // calculate cycle time of this fb
bTriggerArmed :=  bSpeedValid AND bEnable AND (bAutomaticMode OR _bCamManualTeachMode OR _bSimEnable);   // trigger

IF bCamValid THEN    // (not yet used) save dynamic changable settings
  _fTriggerDistance := _iActiveCam.fTriggerDistance;
  _fTriggerLength   := _iActiveCam.fTriggerPulseLength;
END_IF

_bValid := _bStartTrig := FALSE;    // default values (outputs and properties)

manualTrigger();     // handle manual trigger

// enable & reset
rfT_Enable(CLK:=bEnable);             // edge detection (or use bTriggerArmed)
IF rfT_Enable.RT OR rfT_Enable.FT OR bManualReset THEN Reset(); bManualReset:=FALSE; END_IF;
IF NOT bEnable THEN RETURN; END_IF    // do nothing if not enabled
IF NOT bTriggerArmed THEN RETURN; END_IF


// Work
// - detect marks
//   - detect missing marks (based on teach definition, type and a margin)
//   - maybe replace missing marks (trend or teach)
// - handle StartTrigger if StartMark rising edge
// - handle Mark detected position (y-correction)
// - save mark, keep tracking of detected marks, (error handling if some missed)
// - send mark to camera


(*State Machine ----------------------------------------------------------------*)
// select mark
pMarkSearch :=  _pFbMarkDefinition^.getMark(nIdx:=nMarkSelection);
// search for mark
IF checkForMark(pMark:=pMarkSearch, bStartMark=>isStartMark, bErr=>isMarkError) THEN 
  
  // searched start, found start (normal start)
  IF isStartMark AND nMarkSelection = 1 THEN
    IF _pFbMarkDefinition^.nMarks = 1 THEN 
      // only one mark --> TERMINATE + START
      // - start
      SheetStart(pMark:=pMarkSearch);
      IF bR_TerminateLast THEN SheetStop(nNewX0:=0); END_IF  // TERMINATE already after single mark scanned
    ELSE
      // more marks --> START + NEXT
      // - start
      SheetStart(pMark:=pMarkSearch);
      // - next
      nMarkSelection := nMarkSelection + 1;    // next mark
		END_IF

  // search other mark and found start mark (start abort)
  ELSIF isStartMark AND nMarkSelection > 1 THEN
    // terminate(abort) last
    IF nMarkSelection < _pFbMarkDefinition^.nMarks THEN
      LogError('New start mark before last mark detected, missed a mark?');
    END_IF 

    // terminate/abort with new --> TERMINATE + START
    // - start
    SheetStart(pMark:=pMarkSearch);
    
    nMarkSelection := nMarkSelection + 1;    // next mark

  // intermediate marks
  ELSIF NOT isStartMark AND nMarkSelection > 1 THEN
    // search and found other --> NEXT (ev. terminate)
    
    IF _pFbMarkDefinition^.nMarksDetected <= _pFbMarkDefinition^.nMarks THEN
      // - save mark
        _pFbMarkDefinition^.saveMark(pMark:=pMarkSearch);
      // - last mark?
      IF nMarkSelection = _pFbMarkDefinition^.nMarks THEN
        IF bR_TerminateLast THEN SheetStop(nNewX0:=0); END_IF
        nMarkSelection := 1;
      ELSE
        nMarkSelection := nMarkSelection + 1;    // next mark
      END_IF 
    END_IF
	END_IF
END_IF


// outputs
// _bStartTrig := // set in SheetStart
// _nX0 :=  // set in SheetStart
_bValid := TRUE;
]]></ST>
    </Implementation>
    <Folder Name="I_CameraTrigger" Id="{951bb3eb-97c7-4f0d-9018-d2b2f92afa7b}" />
    <Folder Name="I_Sim" Id="{5df11d36-d3ca-4210-8bb0-1fc208e98f36}" />
    <Folder Name="I_StartPosDetect" Id="{e7d8e197-7395-46b8-9002-2d0643b01c02}" />
    <Method Name="analizeMark" Id="{2226e637-ac93-4e17-8c80-c61d8a827017}">
      <Declaration><![CDATA[(*
  Check if mark was detected properly and type matches.
  :returns:  TRUE if in OK area
*)
METHOD PRIVATE analizeMark : BOOL
VAR_INPUT
  pMark           : POINTER TO ST_MarkDefinition;     // mark to search for
  fRealMarkLength : LREAL;                            // real detected mark length [m]
END_VAR
VAR_OUTPUT
  bStartMark : BOOL;     // a start mark was detected
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF pMark = 0 THEN RETURN; END_IF
IF pMark^.fHeight = 0 OR pMark^.fTrLength = 0 THEN analizeMark := TRUE; RETURN; END_IF

(*
  Sensor should aligned to the middle of the sensor (fI_MarkHeight / 2)
  With the difference OF the measured length TO the normal lenght, the fO_LateralOffset can be calculated
  invert in CASE OF wrong mirrored marks 
*)


{warning 'TODO: check if this is correct based on defined mark type'}
pMark^.sState.fLengthReal := fRealMarkLength;
// - dx  (based on sheet begin) dx = current mark position - teached mark position
pMark^.sState.dx := getMarkDistanceEffective(pMark:=pMark) - pMark^.fPosX;
  
// - dy 
pMark^.sState.dy := (pMark^.sState.fLengthReal * (pMark^.fHeight / 2 ) / ((pMark^.fTrLength / 2) + pMark^.fSqLength)) - (pMark^.fHeight / 2 );
IF pMark^.bInvertedX THEN
  pMark^.sState.dy := -1*pMark^.sState.dy;    
END_IF

// check position qualitiy
pMark^.sState.bInArea := FC_COMPARE_RANGE_PERCENT( 
                                       fI_ValueSet := (pMark^.fHeight / 2)
                                     , fI_ValueActual  := (pMark^.fHeight / 2) + pMark^.sState.dy
                                     , fI_RangePercent := nR_AreaMarkSensorOk);

// type of mark
bStartMark := (fRealMarkLength >= _pFbMarkDefinition^.fMinLengthStartMark);
pMark^.sState.bSet := TRUE;

analizeMark := pMark^.sState.bSet;
]]></ST>
      </Implementation>
    </Method>
    <Property Name="bManualTeach" Id="{9ccd84ef-b178-444d-9968-74fe337cc112}" FolderPath="I_CameraTrigger\">
      <Declaration><![CDATA[PROPERTY bManualTeach : BOOL
]]></Declaration>
      <Get Name="Get" Id="{3c621ff5-c2e0-4af4-bc4d-7adec5456f1c}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[bManualTeach := _bCamManualTeachMode;]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{591af842-abd1-4acb-b59a-ff05fb7e464d}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[_bCamManualTeachMode := bManualTeach;]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Property Name="bSimEnable" Id="{8a324fcb-05d0-4beb-acff-031aabaf7968}" FolderPath="I_Sim\">
      <Declaration><![CDATA[{attribute 'monitoring' := 'call'}
(*Simulation is enabled set/get*)
PROPERTY bSimEnable : BOOL
]]></Declaration>
      <Get Name="Get" Id="{7b8886ba-d9fb-42f1-b412-1d65bef226ab}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[bSimEnable := _bSimEnable;]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{c04103e8-063c-4ccc-8026-c70875221124}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[_bSimEnable := bSimEnable;]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Property Name="bStartTrig" Id="{5f1cbe8e-5396-4953-8dea-a9185935d9f4}" FolderPath="I_StartPosDetect\">
      <Declaration><![CDATA[(*
  A new container detected.
  NOTE: a pulse only
*)
PROPERTY bStartTrig : BOOL
]]></Declaration>
      <Get Name="Get" Id="{94ab8131-a50a-4fbf-b08b-6db18e43cad0}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[bStartTrig := _bStartTrig;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="bValid" Id="{758c4d74-99bc-4788-bf04-f29065844fa6}" FolderPath="I_StartPosDetect\">
      <Declaration><![CDATA[(*
  A valid container detected.
*)
PROPERTY bValid : BOOL
]]></Declaration>
      <Get Name="Get" Id="{1296b8e4-740f-4242-bf1b-6d33f3e87748}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[bValid := _bValid;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="calcCycleTime" Id="{3a719839-fb67-4b11-81e5-8be0a942ea69}">
      <Declaration><![CDATA[METHOD PRIVATE calcCycleTime : LREAL
VAR_INPUT
  tCurrent : T_DCTIME64;
END_VAR
VAR_INST
  tLastTimeStamp : T_DCTIME64 := 0;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[calcCycleTime := (TO_LREAL(tCurrent) - TO_LREAL(tLastTimeStamp)) * 1E-9;
tLastTimeStamp  := tCurrent;  // memory timestamp]]></ST>
      </Implementation>
    </Method>
    <Method Name="checkForMark" Id="{09cc2cb3-7a7d-458b-84fd-eeb114800296}">
      <Declaration><![CDATA[(*
  Poll for sensor triggers and marks.
  :return: true if a mark was detected
*)
METHOD PRIVATE checkForMark : BOOL
VAR_INPUT
  pMark : POINTER TO ST_MarkDefinition;             // mark to search for
END_VAR
VAR_OUTPUT
  bErr : BOOL;
  bStartMark : BOOL;     // a start mark was detected
END_VAR
VAR_INST
  rfT_StartSensor                 : RF_TRIG;        // edge detection start trigger
  tRisingEdge, tFallingEdge       : T_DCTIME64;     // detected edges
  nRisingPos, nFallingPos         : DINT;           // detected [SubPx] pos
  fMarkDuration                   : LREAL;
  fDeltaDistance                  : LREAL;          (*Distance that the substrate moved between the detection and the treatment of the information [m]*)
   
  bMarkStartDetected              : BOOL;   // mark started
  bMarkEndDetected                : BOOL;   // marks end reached
  bDone   : BOOL;
  
  // (Todo) inhibit control
  bInhibitTrigger                 : BOOL;       (*inhibit sensor signals, TRUE=inhibit*)
  nInhibitSensorDistance          : DINT;       (*inhibit length in pulseto X0 [SubPx]*)
  bReleaseSensor                  : BOOL;       (*condition to send a stop trigger*)
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF pMark = 0 THEN RETURN; END_IF
IF bDone OR bResetMethods THEN   // reset methods internal states
  bMarkStartDetected := FALSE;
  bMarkEndDetected := FALSE;
  bInhibitTrigger := FALSE;
  bResetMethods := FALSE;
  bErr := FALSE;
  bDone := FALSE;
END_IF

IF _bSimEnable THEN 
  checkForMark := SimMarks(pMark:=pMark, bStartMark=>bStartMark);
  RETURN;
END_IF

rfT_StartSensor(CLK:=bIKp_StartSensor);   // edge detection

// -- rising edge detection
IF rfT_StartSensor.RT AND NOT bInhibitTrigger THEN
  tRisingEdge := tIKp_TimeStampPos;
  bMarkStartDetected := TRUE;
  
  IF bMarkStartDetected OR bMarkEndDetected THEN 
    LogError(F_Concat3('Rigsing trigger while already a ', SEL(bMarkStartDetected, 'falling', 'rising') ,' edge was detected'));
    bErr := TRUE;
    {warning 'TODO: implement a fallback in any case'}
  END_IF
  
 // before calculation with some compensation
(*
  // Calculate the original position in our position domain
  tCurrentTime  := F_GetCurDcTaskTime64();
  fL_CurrentTimeStamp  := (ULINT_TO_LREAL(tCurrentTime) - (nC_CurrentTimeStampComp * 1_000)) / 1_000_000.0; (*in ms*)
  fI_Sensor_TimeStamp := (ULINT_TO_LREAL(tRisingEdge) - (nC_SensorTimeStampComp  * 1_000)) / 1_000_000.0; (*in ms*)

  // Treatment of the information
  fDeltaDistance := (fL_CurrentTimeStamp - fI_Sensor_TimeStamp) * 0.001 * fCurrentSpeed;	(* Distance in pulses that the substrate has traveled between the sensor detection and the PLC treatment *)
  iL_DeltaPosition := FC_LREAL_TO_DINT(fDeltaDistance * (1 / (0.0254 / fI_Resolution)));  (*1/1px*)	(* Travel of the substrate between the time of acquisition and the time of treatment *)
  nOffset_X0       := nCurrentPos - iL_DeltaPosition;	(* Position where the sheet has been detected *)
*)

  // like DMAX
  fDeltaDistance := UINT64_TO_LREAL(UInt64Sub64(ULINT_TO_ULARGE(tNowDc), ULINT_TO_ULARGE(tRisingEdge))) * 1E-9 * fCurrentSpeed;
  nRisingPos := nCurrentPos - F_MeterToSubPixel(fPosMeter:=fDeltaDistance, fResoSubPx:=_fResolution);    (*Position where the sheet has been detected in [SubPx]*) 
END_IF;


// -- falling edge detection
IF rfT_StartSensor.FT AND NOT bInhibitTrigger THEN
  // falling edge
  tFallingEdge := tIKn_TimeStampNeg;
  bMarkEndDetected := TRUE;
  
  fDeltaDistance := UINT64_TO_LREAL(UInt64Sub64(ULINT_TO_ULARGE(tNowDc), ULINT_TO_ULARGE(tFallingEdge))) * 1E-9 * fCurrentSpeed;
  nFallingPos := nCurrentPos - F_MeterToSubPixel(fPosMeter:=fDeltaDistance, fResoSubPx:=_fResolution);    (*Position where the sheet has been detected in [SubPx]*) 

  IF NOT bMarkStartDetected THEN 
    LogError('Missing rigsing trigger edge before falling edge');
    bErr := TRUE;
  END_IF

ELSIF bMarkStartDetected AND (nCurrentPos - nRisingPos) > (nRisingPos + F_MeterToSubPixel(fPosMeter:=pMark^.fTrLength + pMark^.fSqLength + fC_MarkLengthMargin, fResoSubPx:=_fResolution)) THEN
  // Expected falling edge missed
  LogWarning('Mark end missed');
  nFallingPos := nRisingPos + F_MeterToSubPixel(fPosMeter:=pMark^.fTrLength/2+pMark^.fSqLength, fResoSubPx:=_fResolution);
  bMarkEndDetected := TRUE;
  pMark^.sState.bMissed := TRUE;
  
END_IF;


// -- mark evaluation
IF bMarkStartDetected AND bMarkEndDetected THEN
  // mark finished
  
  // - define mark
  pMark^.sState.nPosXReal := nRisingPos;  // save detected mark pos
  fMarkDuration    := (ULINT_TO_LREAL(tFallingEdge) - ULINT_TO_LREAL(tRisingEdge));		// Calculate how long the signal was ON
  
  // check mark & calculate offsets
  IF analizeMark( pMark:=pMark, fRealMarkLength:=fMarkDuration * fCurrentSpeed * 0.000_000_001, bStartMark => bStartMark ) THEN
    checkForMark := TRUE;
  ELSE
   bErr := TRUE;  // invalid mark detected
	END_IF
  
  bDone := TRUE;   // done, reset states

ELSIF bErr THEN
  bDone := TRUE;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="Disable" Id="{cfef52af-6d49-44b6-9c3e-ba52ccce2a01}" FolderPath="I_CameraTrigger\">
      <Declaration><![CDATA[METHOD Disable : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[_iActiveCam := 0;
Disable := TRUE;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="Enable" Id="{fad3ab13-8e5e-43fa-9e5c-21e5bd36b7b3}" FolderPath="I_CameraTrigger\">
      <Declaration><![CDATA[METHOD Enable : BOOL
VAR_INPUT
	iCam	                    : I_CameraTriggerDevice;
  bUseCameraTrigger         : BOOL; //Generate camera trigger
  bUseCameraTriggerFeedback : BOOL; //Use feedback as trigger?
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF iCam = 0 THEN
  Enable := FALSE;
  LogError('setCam failed: invalid reference');
ELSE
  _iActiveCam := iCam;
  Enable     := TRUE;

  // save constant settings
  _bUseCameraTrigger := bUseCameraTrigger;
  _bUseCameraTriggerFeedback := bUseCameraTriggerFeedback;
  
  IF _bUseCameraTrigger OR _bUseCameraTriggerFeedback THEN
    LogWarning('Enable: Camera Trigger output/feedback not yet supported');
	END_IF
END_IF;]]></ST>
      </Implementation>
    </Method>
    <Method Name="getLastX0" Id="{c2e4e46e-b947-4396-bff2-ebd04f62309e}">
      <Declaration><![CDATA[(*
  Get X0 from detected start mark
*)
METHOD PRIVATE getLastX0 : DINT
VAR
  pLastStartMark : POINTER TO ST_MarkDefinition;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[pLastStartMark := _pFbMarkDefinition^.pLastStartMark;

IF pLastStartMark <> 0 THEN
  getLastX0 := pLastStartMark^.sState.nPosXReal - F_MeterToSubPixel(fPosMeter:=pLastStartMark^.fPosX, fResoSubPx:=_fResolution);
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="getMarkDistanceEffective" Id="{1b9471fe-46cb-43fb-9cdf-f1002616e846}">
      <Declaration><![CDATA[(*
  Calculate effective distance of mark to X0 [m]
*)
METHOD PRIVATE getMarkDistanceEffective : LREAL
VAR_INPUT
  pMark : POINTER TO ST_MarkDefinition;
END_VAR
VAR
  pFirstMark : POINTER TO ST_MarkDefinition;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF pMark = 0 THEN RETURN; END_IF

IF pMark^.nId = 1 THEN 
  getMarkDistanceEffective := pMark^.fPosX;
ELSE
  pFirstMark := _pFbMarkDefinition^.getMark(nIdx:=1);
  // real distance between this mark and start mark + fPosX of start mark
  getMarkDistanceEffective := pFirstMark^.fPosX + F_SubPixelToMeter(lPosSubPx:=pMark^.sState.nPosXReal - pFirstMark^.sState.nPosXReal, fResSubPx:=_fResolution);
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="Init" Id="{3330532e-1984-4d2a-add5-4d053cb8bee0}">
      <Declaration><![CDATA[METHOD Init
VAR_INPUT
  fPrintResolution      : LREAL := 600;         // print(head) resolution in [dpi]
  fSubPxResolution      : LREAL := 32;          // SubPixel resolution [SubPx], resolution factor (fI_PrintResolution*fI_SubPxResolution=>Output resolution)
  pFbMarkDefinition     : POINTER TO FB_MarkDefinition;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF fPrintResolution = 0 OR fSubPxResolution = 0 OR pFbMarkDefinition = 0 THEN LogError('Init: invalid parameter'); RETURN; END_IF

_fResolution := fPrintResolution * fSubPxResolution;
_pFbMarkDefinition:= pFbMarkDefinition;

Reset();
bInitOk := TRUE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="manualTrigger" Id="{8dc41e87-4c55-4c20-97ff-5b47254e2b36}">
      <Declaration><![CDATA[METHOD PRIVATE manualTrigger : BOOL
VAR_INST
  rfTrig_ManuTrigger : RF_TRIG;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[rfTrig_ManuTrigger(CLK:=bManualTrigger);

IF rfTrig_ManuTrigger.RT THEN
  LogWarning('manualTrigger not yet implemented');
END_IF

manualTrigger := rfTrig_ManuTrigger.RT;]]></ST>
      </Implementation>
    </Method>
    <Property Name="nPrintMarkPosBits" Id="{f9b16fa7-004c-4f94-b9bf-e4f4102484ed}">
      <Declaration><![CDATA[(*Print mark position (bit coded)*)
  (*Bit 0: no mark*)
  (*Bit 1: mark on drive side*)
  (*Bit 2: mark in center range*)
  (*Bit 3: mark on control side*)
PROPERTY nPrintMarkPosBits : WORD]]></Declaration>
      <Get Name="Get" Id="{e582339e-8abd-4811-a680-cb6add3334e6}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[{warning 'TODO: implement'}
(*Print mark position (bit coded)*)
  (*Bit 0: no mark*)
  (*Bit 1: mark on drive side*)
  (*Bit 2: mark in center range*)
  (*Bit 3: mark on control side*)
nPrintMarkPosBits := 0;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="nStartPositionX0" Id="{9b7e63ec-5a5b-4e34-a5d4-8c28025cc103}" FolderPath="I_StartPosDetect\">
      <Declaration><![CDATA[(*
  Detected start position X0 (absolute) in [SubPx].
*)
PROPERTY nStartPositionX0 : DINT
]]></Declaration>
      <Get Name="Get" Id="{b2a61633-5ff3-44c0-a7bd-eef4cd7213ae}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[nStartPositionX0 := _nX0;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="Reset" Id="{0cd8fba4-b26a-4d0c-9e5a-4fd1da9e4425}">
      <Declaration><![CDATA[(*
  Reset internal state and all marks
*)
METHOD Reset
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF NOT bInitOk THEN RETURN; END_IF

_bValid := FALSE;
_bStartTrig := FALSE;
nMarkSelection := 1; // start mark

// reset camera (release if one is selected)
IF bSheetActive THEN
  IF _iActiveCam <> 0 THEN _iActiveCam.CamTriggerDone(); END_IF   // notify an done/abort
END_IF
_pFbMarkDefinition^.ResetMarkStates();  // reset detected marks
bSheetActive := FALSE;
bResetMethods := TRUE;        // reset checkForMark() state machine
]]></ST>
      </Implementation>
    </Method>
    <Method Name="SetSubstrateLength" Id="{67d10d0f-5946-4788-b994-e8b0f154d48a}" FolderPath="I_CameraTrigger\">
      <Declaration><![CDATA[METHOD SetSubstrateLength
VAR_INPUT
  fSubstrateLength : LREAL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF NOT bInitOk THEN RETURN;END_IF;

(*reduced by margin (for endless mode with potential smaller printed repetition)*)
_fSubstrateLength := fSubstrateLength;
//_nSubstrateLength := F_MeterToSubPixel(fPosMeter:=_fSubstrateLength, fResoSubPx:=_fResolution);]]></ST>
      </Implementation>
    </Method>
    <Method Name="SheetStart" Id="{e59349fa-2f99-425a-926a-8c081bd5049e}">
      <Declaration><![CDATA[METHOD PRIVATE SheetStart
VAR_INPUT
  pMark : POINTER TO ST_MarkDefinition;
END_VAR
VAR
  sMarkBackup : ST_MarkDefinition;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[_nX0 := pMark^.sState.nPosXReal - F_MeterToSubPixel(fPosMeter:=pMark^.fPosX, fResoSubPx:=_fResolution);
_bStartTrig := TRUE;

// (force) terminate a sheet
IF bSheetActive THEN 
  sMarkBackup := pMark^;   // push 
  SheetStop(nNewX0:=_nX0);
  pMark^:= sMarkBackup;    // pop
END_IF

// save (start) mark
_pFbMarkDefinition^.saveMark(pMark:=pMark);

// trigger camera
IF _iActiveCam<>0 THEN _iActiveCam.CamTrigger(bOk:=TRUE, nPos:=_nX0, nPosDeviation:=0); END_IF

bSheetActive := TRUE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="SheetStop" Id="{109ba6fa-ffe7-4a58-8b01-744c1a4dcc03}">
      <Declaration><![CDATA[METHOD PRIVATE SheetStop
VAR_INPUT
  nNewX0 : DINT;   // new detected X0
END_VAR
VAR
  pLastMark : POINTER TO ST_MarkDefinition;
  pBorderMark : POINTER TO ST_MarkDefinition;
  fD : LREAL;
  fSLen : LREAL;
  nDetectedX0 : DINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// - terminate

fSLen := _fSubstrateLength;  // (default) original length

// calculate effective sheet length
nDetectedX0 := getLastX0();   // get sampled X0
IF nNewX0 <> 0 AND nDetectedX0 <> 0 THEN
  // real diff between two starts
  fD := F_SubPixelToMeter(lPosSubPx:=nNewX0 - nDetectedX0, fResSubPx:=_fResolution);
  IF fD < (_fSubstrateLength * fC_MaxSubstrateFactor) THEN
    fSLen := fD;
  END_IF 
ELSIF nNewX0 = 0 AND _pFbMarkDefinition^.nMarksDetected > 1 THEN
  // calculate based on last detected mark (a strech factor)
  pLastMark:= _pFbMarkDefinition^.getMark(nIdx:=0);     // get last available mark
  fD := getMarkDistanceEffective(pMark:=pLastMark);
  fSLen := (pLastMark^.fPosX/SEL(fD<>0, pLastMark^.fPosX, fD)) * _fSubstrateLength;
END_IF
_fSubstrateLengthEffective := fSLen;


// set sheet border point
pBorderMark := _pFbMarkDefinition^.getMark(nIdx:=-1);
IF pBorderMark <> 0 THEN
  pBorderMark^.sState.bSet      := TRUE;
  pBorderMark^.fPosX            := _fSubstrateLength;
  pBorderMark^.fPosY            := 0;
  pBorderMark^.sState.dx        := _fSubstrateLengthEffective - _fSubstrateLength;
  pBorderMark^.sState.dy        := 0;
  pBorderMark^.sState.nPosXReal := SEL(nNewX0=0, nNewX0, nDetectedX0 + F_MeterToSubPixel(fPosMeter:=_fSubstrateLengthEffective, fResoSubPx:=_fResolution) );
  // no size information
  _pFbMarkDefinition^.saveMark(pMark:=pBorderMark);
END_IF


IF _iActiveCam<>0 THEN _iActiveCam.CamTriggerDone(); END_IF 
_pFbMarkDefinition^.ResetMarkStates();

bSheetActive := FALSE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="SimMarks" Id="{8373fdd1-b119-4d9c-8c3b-21226d870047}">
      <Declaration><![CDATA[METHOD PRIVATE SimMarks : BOOL
VAR_INPUT
  pMark : POINTER TO ST_MarkDefinition;
END_VAR
VAR_OUTPUT
  nX0 : DINT;
  bStartMark : BOOL;
END_VAR
VAR_INST
  bMarkOn : BOOL;
  nMarkStarted : DINT;
  fStartMarkOffset : LREAL;
  nLastStartMark : DINT;  // last detected start mark
  tTon_Mark : TON;
  rand : DRAND;
  rlrand : LREAL;
  l : DINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF pMark = 0 THEN RETURN; END_IF

// when sim enabled AND auto-trigger then create a StartMark after every sheet/repeate length
//  then generate every following intermediate mark with a given length

IF NOT bMarkOn THEN  // start new mark
  // create rising edge
  IF pMark^.nId = 1 THEN
    // wait for next StartPosition
    IF F_SubPixelToMeter(lPosSubPx:=nCurrentPos - nLastStartMark, fResSubPx:=_fResolution) >= _fSubstrateLength THEN
      nLastStartMark := nCurrentPos;      // save start mark pos
      fStartMarkOffset := pMark^.fPosX;   // save start mark displacement from X0
      pMark^.sState.nPosXReal := nCurrentPos;  // save rising edge
      nMarkStarted := nCurrentPos;
      l := F_MeterToSubPixel(fPosMeter:=pMark^.fSqLength + (pMark^.fTrLength/2), fResoSubPx:=_fResolution); // mark length
      bMarkOn := TRUE;
    END_IF
	ELSE
    // wait for next mark position
    IF F_SubPixelToMeter(lPosSubPx:=nCurrentPos - nLastStartMark, fResSubPx:=_fResolution) >= pMark^.fPosX - fStartMarkOffset THEN
      pMark^.sState.nPosXReal := nCurrentPos;  // save rising edge
      nMarkStarted := nCurrentPos;
      l := F_MeterToSubPixel(fPosMeter:=pMark^.fSqLength + (pMark^.fTrLength/2), fResoSubPx:=_fResolution); // mark length
      bMarkOn := TRUE;
		END_IF
  END_IF
  
ELSE
  // create falling edge
  IF (nCurrentPos - nMarkStarted) > l THEN
    rand(Seed:=13, Num=>rlrand);  // TODO: find a right scale 
    analizeMark(pMark:=pMark, fRealMarkLength:=F_SubPixelToMeter(lPosSubPx:=nCurrentPos - nMarkStarted, fResSubPx:=_fResolution));
    bMarkOn := FALSE;
    If pMark^.nId = 1 THEN bStartMark := TRUE; END_IF
    SimMarks := TRUE;    // mark done
  END_IF
END_IF
]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="FB_MarkDetection">
      <LineId Id="10360" Count="23" />
      <LineId Id="10757" Count="0" />
      <LineId Id="10384" Count="13" />
      <LineId Id="10758" Count="0" />
      <LineId Id="10398" Count="0" />
      <LineId Id="10542" Count="0" />
      <LineId Id="10564" Count="0" />
      <LineId Id="10403" Count="0" />
      <LineId Id="10405" Count="3" />
      <LineId Id="10567" Count="0" />
      <LineId Id="10409" Count="1" />
      <LineId Id="10523" Count="0" />
      <LineId Id="10520" Count="2" />
      <LineId Id="10411" Count="0" />
      <LineId Id="10552" Count="8" />
      <LineId Id="10563" Count="0" />
      <LineId Id="10550" Count="0" />
      <LineId Id="10577" Count="0" />
      <LineId Id="10565" Count="0" />
      <LineId Id="10576" Count="0" />
      <LineId Id="10551" Count="0" />
      <LineId Id="10412" Count="1" />
      <LineId Id="10665" Count="1" />
      <LineId Id="10528" Count="1" />
      <LineId Id="10526" Count="1" />
      <LineId Id="10531" Count="0" />
      <LineId Id="10669" Count="0" />
      <LineId Id="10535" Count="1" />
      <LineId Id="10530" Count="0" />
      <LineId Id="10668" Count="0" />
      <LineId Id="10414" Count="1" />
      <LineId Id="10566" Count="0" />
      <LineId Id="10514" Count="4" />
      <LineId Id="6884" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkDetection.analizeMark">
      <LineId Id="173" Count="15" />
      <LineId Id="206" Count="0" />
      <LineId Id="189" Count="0" />
      <LineId Id="207" Count="0" />
      <LineId Id="190" Count="0" />
      <LineId Id="194" Count="11" />
      <LineId Id="46" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkDetection.bManualTeach.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkDetection.bManualTeach.Set">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkDetection.bSimEnable.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkDetection.bSimEnable.Set">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkDetection.bStartTrig.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkDetection.bValid.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkDetection.calcCycleTime">
      <LineId Id="5" Count="0" />
      <LineId Id="8" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkDetection.checkForMark">
      <LineId Id="95" Count="0" />
      <LineId Id="199" Count="0" />
      <LineId Id="201" Count="2" />
      <LineId Id="207" Count="0" />
      <LineId Id="204" Count="2" />
      <LineId Id="208" Count="0" />
      <LineId Id="235" Count="0" />
      <LineId Id="239" Count="0" />
      <LineId Id="241" Count="0" />
      <LineId Id="240" Count="0" />
      <LineId Id="15" Count="0" />
      <LineId Id="5" Count="0" />
      <LineId Id="21" Count="5" />
      <LineId Id="280" Count="2" />
      <LineId Id="287" Count="0" />
      <LineId Id="279" Count="0" />
      <LineId Id="278" Count="0" />
      <LineId Id="27" Count="13" />
      <LineId Id="43" Count="1" />
      <LineId Id="46" Count="4" />
      <LineId Id="277" Count="0" />
      <LineId Id="51" Count="1" />
      <LineId Id="113" Count="0" />
      <LineId Id="115" Count="1" />
      <LineId Id="58" Count="2" />
      <LineId Id="109" Count="0" />
      <LineId Id="65" Count="0" />
      <LineId Id="111" Count="0" />
      <LineId Id="66" Count="0" />
      <LineId Id="96" Count="0" />
      <LineId Id="85" Count="0" />
      <LineId Id="112" Count="0" />
      <LineId Id="117" Count="0" />
      <LineId Id="110" Count="0" />
      <LineId Id="283" Count="0" />
      <LineId Id="19" Count="0" />
      <LineId Id="156" Count="1" />
      <LineId Id="104" Count="0" />
      <LineId Id="71" Count="1" />
      <LineId Id="244" Count="0" />
      <LineId Id="134" Count="0" />
      <LineId Id="138" Count="0" />
      <LineId Id="284" Count="1" />
      <LineId Id="159" Count="0" />
      <LineId Id="140" Count="0" />
      <LineId Id="160" Count="0" />
      <LineId Id="165" Count="1" />
      <LineId Id="161" Count="0" />
      <LineId Id="135" Count="0" />
      <LineId Id="132" Count="0" />
      <LineId Id="162" Count="0" />
      <LineId Id="130" Count="0" />
      <LineId Id="164" Count="0" />
      <LineId Id="73" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkDetection.Disable">
      <LineId Id="4" Count="0" />
      <LineId Id="14" Count="0" />
      <LineId Id="9" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkDetection.Enable">
      <LineId Id="31" Count="0" />
      <LineId Id="48" Count="1" />
      <LineId Id="34" Count="0" />
      <LineId Id="50" Count="0" />
      <LineId Id="36" Count="0" />
      <LineId Id="89" Count="0" />
      <LineId Id="78" Count="0" />
      <LineId Id="51" Count="0" />
      <LineId Id="80" Count="0" />
      <LineId Id="99" Count="0" />
      <LineId Id="96" Count="2" />
      <LineId Id="70" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkDetection.getLastX0">
      <LineId Id="16" Count="1" />
      <LineId Id="5" Count="0" />
      <LineId Id="11" Count="0" />
      <LineId Id="18" Count="0" />
      <LineId Id="15" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkDetection.getMarkDistanceEffective">
      <LineId Id="5" Count="0" />
      <LineId Id="11" Count="0" />
      <LineId Id="10" Count="0" />
      <LineId Id="15" Count="0" />
      <LineId Id="12" Count="0" />
      <LineId Id="19" Count="0" />
      <LineId Id="21" Count="0" />
      <LineId Id="20" Count="0" />
      <LineId Id="13" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkDetection.Init">
      <LineId Id="5" Count="0" />
      <LineId Id="12" Count="0" />
      <LineId Id="11" Count="0" />
      <LineId Id="10" Count="0" />
      <LineId Id="14" Count="0" />
      <LineId Id="9" Count="0" />
      <LineId Id="8" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkDetection.manualTrigger">
      <LineId Id="5" Count="0" />
      <LineId Id="11" Count="0" />
      <LineId Id="10" Count="0" />
      <LineId Id="13" Count="0" />
      <LineId Id="12" Count="0" />
      <LineId Id="8" Count="0" />
      <LineId Id="7" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkDetection.nPrintMarkPosBits.Get">
      <LineId Id="5" Count="0" />
      <LineId Id="9" Count="3" />
      <LineId Id="8" Count="0" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkDetection.nStartPositionX0.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkDetection.Reset">
      <LineId Id="19" Count="1" />
      <LineId Id="13" Count="0" />
      <LineId Id="23" Count="0" />
      <LineId Id="16" Count="0" />
      <LineId Id="34" Count="0" />
      <LineId Id="28" Count="0" />
      <LineId Id="25" Count="2" />
      <LineId Id="29" Count="0" />
      <LineId Id="39" Count="0" />
      <LineId Id="22" Count="0" />
      <LineId Id="18" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkDetection.SetSubstrateLength">
      <LineId Id="8" Count="1" />
      <LineId Id="6" Count="0" />
      <LineId Id="14" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkDetection.SheetStart">
      <LineId Id="22" Count="0" />
      <LineId Id="21" Count="0" />
      <LineId Id="35" Count="0" />
      <LineId Id="16" Count="1" />
      <LineId Id="27" Count="0" />
      <LineId Id="25" Count="0" />
      <LineId Id="28" Count="0" />
      <LineId Id="26" Count="0" />
      <LineId Id="15" Count="0" />
      <LineId Id="8" Count="1" />
      <LineId Id="37" Count="0" />
      <LineId Id="10" Count="0" />
      <LineId Id="5" Count="0" />
      <LineId Id="13" Count="0" />
      <LineId Id="12" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkDetection.SheetStop">
      <LineId Id="54" Count="0" />
      <LineId Id="88" Count="0" />
      <LineId Id="55" Count="0" />
      <LineId Id="89" Count="0" />
      <LineId Id="56" Count="0" />
      <LineId Id="59" Count="2" />
      <LineId Id="73" Count="1" />
      <LineId Id="62" Count="0" />
      <LineId Id="75" Count="0" />
      <LineId Id="63" Count="5" />
      <LineId Id="110" Count="0" />
      <LineId Id="109" Count="0" />
      <LineId Id="91" Count="0" />
      <LineId Id="90" Count="0" />
      <LineId Id="94" Count="0" />
      <LineId Id="96" Count="0" />
      <LineId Id="108" Count="0" />
      <LineId Id="98" Count="0" />
      <LineId Id="101" Count="0" />
      <LineId Id="104" Count="3" />
      <LineId Id="85" Count="0" />
      <LineId Id="92" Count="0" />
      <LineId Id="84" Count="0" />
      <LineId Id="69" Count="3" />
      <LineId Id="9" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkDetection.SimMarks">
      <LineId Id="28" Count="0" />
      <LineId Id="54" Count="0" />
      <LineId Id="5" Count="0" />
      <LineId Id="31" Count="0" />
      <LineId Id="68" Count="0" />
      <LineId Id="67" Count="0" />
      <LineId Id="83" Count="0" />
      <LineId Id="74" Count="0" />
      <LineId Id="78" Count="0" />
      <LineId Id="82" Count="0" />
      <LineId Id="75" Count="0" />
      <LineId Id="87" Count="0" />
      <LineId Id="95" Count="0" />
      <LineId Id="97" Count="0" />
      <LineId Id="104" Count="0" />
      <LineId Id="91" Count="0" />
      <LineId Id="81" Count="0" />
      <LineId Id="76" Count="0" />
      <LineId Id="92" Count="0" />
      <LineId Id="80" Count="0" />
      <LineId Id="98" Count="0" />
      <LineId Id="129" Count="0" />
      <LineId Id="105" Count="0" />
      <LineId Id="89" Count="1" />
      <LineId Id="79" Count="0" />
      <LineId Id="110" Count="0" />
      <LineId Id="71" Count="0" />
      <LineId Id="93" Count="0" />
      <LineId Id="100" Count="0" />
      <LineId Id="106" Count="0" />
      <LineId Id="99" Count="0" />
      <LineId Id="108" Count="0" />
      <LineId Id="128" Count="0" />
      <LineId Id="109" Count="0" />
      <LineId Id="102" Count="0" />
      <LineId Id="70" Count="0" />
      <LineId Id="42" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>