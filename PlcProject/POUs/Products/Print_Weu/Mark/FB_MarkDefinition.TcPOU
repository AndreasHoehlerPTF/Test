<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.11">
  <POU Name="FB_MarkDefinition" Id="{6e7a8d5d-62b5-4788-a589-5b2aa5bdfe8a}" SpecialFunc="None">
    <Declaration><![CDATA[(*
  Holds Marks definition & current state.
*)
{attribute 'no_explicit_call' := 'do not call this POU directly'} 
FUNCTION_BLOCK FB_MarkDefinition EXTENDS T_NamedBase IMPLEMENTS I_MarkDefinition
VAR
  // marks
  // - mark list
  _nMarks : UDINT;          // number of registered (teached) marks
  sMarkDef : ARRAY[1..50] OF ST_MarkDefinition;   // teached marks
  // - border mark
  _bBorderMarkUsed : BOOL;   // a border mark was teached
  sSheetBorderEndMark : ST_MarkDefinition;  // internal mark created on edge of sheet (used for effective sheet length)
  
  // mark states
  _nMarksDetected : UDINT;  // number of detected marks
  _bSheetBorderDetected : BOOL;
  _fSubstrateLengthEffective      : LREAL;        // detected substrate length

  // internals
  nMaxMarks : UDINT;
  sLastStartMark : ST_MarkDefinition;       // sampled start mark (because first mark will be overwritten already by next sheet)
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[(*
  Definition of a mark.
  
   SqLength | TrLength -->
   |--------|--------
   |        |      /
   |        |    / -- center --
^  |        |  /
|  |--------|
| Height

Requirements:
  - StartMark has to be unique (minimal length > than max. length of Other marks)
  - Distance between Start and Endmark has to be bigger than length of StartMark + Minimal space
  - Mark has a minimum lenth, so the sensor can see the mark

*)]]></ST>
    </Implementation>
    <Folder Name="I_MarkDefinition" Id="{16b91438-f803-4348-8fb7-10427a0559c7}" />
    <Property Name="fMinLengthStartMark" Id="{705ebcdd-238b-47da-959e-455080336d6d}">
      <Declaration><![CDATA[(*
  Ge minimum length of hte start mark.
*)
PROPERTY fMinLengthStartMark : LREAL]]></Declaration>
      <Get Name="Get" Id="{63d98c65-eb9d-4b9b-8f6a-8fff1e96a632}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[IF _nMarks > 0 THEN
  fMinLengthStartMark := sMarkDef[1].fSqLength;
END_IF]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="getMark" Id="{f29eb549-d305-4b12-aef3-17f1ca168c27}" FolderPath="I_MarkDefinition\">
      <Declaration><![CDATA[(*
  Get a mark definition.
  nIdx= 1.._nMarks = registered marks
  nIdx= 0 - selects last mark 
  nIdx=-1 - selects border mark
  :returns: pointer to mark defintion or 0 if not found
*)
METHOD getMark : POINTER TO ST_MarkDefinition
VAR_INPUT
  nIdx : DINT; // mark index: 1.._nMarks, 0 = last (endMark) 
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF    nIdx = 0 THEN 
  getMark := ADR(sMarkDef[_nMarks]); // last mark (end or last)
ELSIF nIdx = -1 THEN
  IF _bBorderMarkUsed THEN
    getMark := ADR(sSheetBorderEndMark);  // sheet border mark
  END_IF  
ELSIF nIdx > 0 AND nIdx <= TO_DINT(_nMarks) THEN 
  getMark := ADR(sMarkDef[nIdx]);
ELSE 
  LogError(F_Concat2('Invalid mark requested, Idx=', TO_STRING(nIdx)));
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="Init" Id="{c20f7e1a-764c-46a0-893a-db27e9de0985}">
      <Declaration><![CDATA[METHOD Init : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[nMaxMarks := SIZEOF(sMarkDef) / SIZEOF(sMarkDef[1]);
ResetDefinition();]]></ST>
      </Implementation>
    </Method>
    <Property Name="nMarks" Id="{92120eb8-4bf0-4904-95cc-6a6ba8d23ff4}" FolderPath="I_MarkDefinition\">
      <Declaration><![CDATA[(*Number of registered marks*)
PROPERTY nMarks : UDINT]]></Declaration>
      <Get Name="Get" Id="{7eb15e29-897b-4a06-a6bd-f18ba5406d05}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[nMarks := _nMarks + SEL(_bBorderMarkUsed, 0, 1);]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="nMarksDetected" Id="{582f7c32-2eae-4b7f-bda7-4a884804f2ab}" FolderPath="I_MarkDefinition\">
      <Declaration><![CDATA[(*Number of detected marks*)
PROPERTY nMarksDetected : UDINT]]></Declaration>
      <Get Name="Get" Id="{40bb2dbf-cb04-4ac7-b848-2727fd7b35e1}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[// number of detected marks + sheetborder if used
nMarksDetected := _nMarksDetected + SEL(_bBorderMarkUsed AND _bSheetBorderDetected, 0, 1);]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="pLastStartMark" Id="{5fb74e36-4455-4887-92a4-c74cb00c2de7}">
      <Declaration><![CDATA[PROPERTY pLastStartMark : POINTER TO ST_MarkDefinition]]></Declaration>
      <Get Name="Get" Id="{b60e15fe-11f8-4772-84e1-1358cafac471}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[pLastStartMark := ADR(sLastStartMark);]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="RegisterMark" Id="{fb7b9469-75c3-49cc-8ce1-a384ac9c5291}" FolderPath="I_MarkDefinition\">
      <Declaration><![CDATA[(*
  Register a mark to camera (teach).
  If mark.nId >= 0 then it will be a detectable mark.
  If mark.nId = -1 it will be the sheet-end border mark
*)
METHOD RegisterMark : BOOL
VAR_INPUT
  sMark : ST_MarkDefinition;
END_VAR
VAR
  pMark : POINTER TO ST_MarkDefinition;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF sMark.nId = -1 THEN
  // - border mark
  _bBorderMarkUsed := TRUE;
  pMark := ADR(sSheetBorderEndMark);
  // copy mark data
  pMark^ := sMark;
  // view 
  pMark^.bShow := FALSE;
  pMark^.nMove := TO_DINT(_nMarks+1);
ELSE
  // - for all other teach marks
  IF _nMarks >= nMaxMarks THEN LogError('Number of marks exeeded, ignore'); RETURN; END_IF
  // we assume first mark is start mark, last mark is end mark (marks need to be registered in sorted order)
  // (TODO) otherwise add marks in a sorted way to list
  _nMarks := _nMarks + 1;
  pMark := ADR(sMarkDef[_nMarks]);
  // copy mark data
  pMark^ := sMark;

  // set id if not given
  IF pMark^.nId = 0 THEN pMark^.nId := TO_DINT(_nMarks); END_IF
  
  // view
  pMark^.bShow := TRUE;
  pMark^.nMove := TO_DINT(pMark^.nId-1);
  
  // checks
  IF _nMarks > 1 THEN   
    // -- start mark length requirement 
    IF pMark^.fSqLength + pMark^.fTrLength >= sMarkDef[1].fSqLength THEN 
      LogError(F_Concat5('RegisterMark: mark not unique, too long: ', TO_STRING(pMark^.fSqLength + pMark^.fTrLength), ' > ', TO_STRING(sMarkDef[1].fSqLength), ' of start min. length'));
    END_IF
  END_IF
END_IF  


// clear eventual mark state
MEMSET(destAddr:=ADR(pMark^.sState), 0, SIZEOF(ST_MarkState));

RegisterMark := TRUE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="ResetDefinition" Id="{4875f2f3-b9db-40c2-9f72-920f74fab8f1}" FolderPath="I_MarkDefinition\">
      <Declaration><![CDATA[METHOD ResetDefinition
VAR
  i : UDINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[ResetMarkStates();

_nMarks := 0;
_bBorderMarkUsed:=FALSE;

MEMSET(destAddr:=ADR(sMarkDef), fillByte:=0, SIZEOF(sMarkDef));
MEMSET(destAddr:=ADR(sLastStartMark), fillByte:=0, SIZEOF(sLastStartMark));
MEMSET(destAddr:=ADR(sSheetBorderEndMark), fillByte:=0, SIZEOF(sSheetBorderEndMark));
// prepare border point
sSheetBorderEndMark.nId := -1;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="ResetMarkStates" Id="{227543d6-3613-4076-8bf0-3ecac98acbd2}" FolderPath="I_MarkDefinition\">
      <Declaration><![CDATA[(*
  Reset all registered marks
*)
METHOD ResetMarkStates
VAR
  i : UDINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// reset detected marks
_nMarksDetected := 0;
_bSheetBorderDetected := FALSE;
_fSubstrateLengthEffective := 0;
// reset mark state only
FOR i:=1 TO _nMarks DO
  MEMSET(destAddr:=ADR(sMarkDef[i].sState), 0, SIZEOF(ST_MarkState));
END_FOR
//MEMSET(destAddr:=ADR(sLastStartMark.sState), 0, SIZEOF(ST_MarkState));
MEMSET(destAddr:=ADR(sSheetBorderEndMark.sState), 0, SIZEOF(ST_MarkState));
]]></ST>
      </Implementation>
    </Method>
    <Method Name="saveMark" Id="{a599fd59-b013-4c00-ac0a-60c8cf813a40}">
      <Declaration><![CDATA[METHOD saveMark : BOOL
VAR_INPUT
  pMark : POINTER TO ST_MarkDefinition;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF pMark = 0 THEN RETURN; END_IF

// sample start mark
IF pMark^.nId = 1 THEN 
  sLastStartMark := pMark^;           // save start mark as backup
  sMarkDef[pMark^.nId] := pMark^;     // save in teached mark table
  _nMarksDetected := _nMarksDetected + 1;
  saveMark := TRUE;

ELSIF pMark^.nId = -1 AND _bBorderMarkUsed THEN
  sSheetBorderEndMark := pMark^;     // save sheet border point
  _bSheetBorderDetected := TRUE;
  saveMark := TRUE;
  
ELSIF pMark^.nId > 1 AND pMark^.nId <= TO_DINT(_nMarks) THEN
  sMarkDef[pMark^.nId] := pMark^;     // save in teached mark table
  _nMarksDetected := _nMarksDetected + 1;
  saveMark := TRUE;  
  
ELSE
  LogError(F_Concat3('saveMark: mark with id=', TO_STRING(pMark^.nId), ' not available'));
END_IF

]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="FB_MarkDefinition">
      <LineId Id="9" Count="0" />
      <LineId Id="24" Count="1" />
      <LineId Id="31" Count="5" />
      <LineId Id="29" Count="1" />
      <LineId Id="37" Count="0" />
      <LineId Id="26" Count="0" />
      <LineId Id="28" Count="0" />
      <LineId Id="38" Count="0" />
      <LineId Id="27" Count="0" />
      <LineId Id="23" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkDefinition.fMinLengthStartMark.Get">
      <LineId Id="2" Count="0" />
      <LineId Id="5" Count="1" />
    </LineIds>
    <LineIds Name="FB_MarkDefinition.getMark">
      <LineId Id="5" Count="0" />
      <LineId Id="22" Count="0" />
      <LineId Id="21" Count="0" />
      <LineId Id="38" Count="0" />
      <LineId Id="23" Count="0" />
      <LineId Id="39" Count="0" />
      <LineId Id="10" Count="0" />
      <LineId Id="24" Count="0" />
      <LineId Id="7" Count="0" />
      <LineId Id="37" Count="0" />
      <LineId Id="8" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkDefinition.Init">
      <LineId Id="13" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkDefinition.nMarks.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkDefinition.nMarksDetected.Get">
      <LineId Id="5" Count="0" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkDefinition.pLastStartMark.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkDefinition.RegisterMark">
      <LineId Id="83" Count="0" />
      <LineId Id="103" Count="0" />
      <LineId Id="96" Count="1" />
      <LineId Id="121" Count="0" />
      <LineId Id="135" Count="0" />
      <LineId Id="124" Count="0" />
      <LineId Id="122" Count="1" />
      <LineId Id="93" Count="0" />
      <LineId Id="98" Count="4" />
      <LineId Id="128" Count="0" />
      <LineId Id="125" Count="0" />
      <LineId Id="133" Count="1" />
      <LineId Id="131" Count="1" />
      <LineId Id="127" Count="0" />
      <LineId Id="118" Count="2" />
      <LineId Id="116" Count="0" />
      <LineId Id="106" Count="4" />
      <LineId Id="115" Count="0" />
      <LineId Id="105" Count="0" />
      <LineId Id="85" Count="0" />
      <LineId Id="89" Count="0" />
      <LineId Id="31" Count="0" />
      <LineId Id="29" Count="0" />
      <LineId Id="27" Count="0" />
      <LineId Id="47" Count="0" />
      <LineId Id="13" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkDefinition.ResetDefinition">
      <LineId Id="25" Count="2" />
      <LineId Id="40" Count="1" />
      <LineId Id="28" Count="3" />
      <LineId Id="34" Count="0" />
      <LineId Id="39" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkDefinition.ResetMarkStates">
      <LineId Id="17" Count="0" />
      <LineId Id="5" Count="0" />
      <LineId Id="45" Count="0" />
      <LineId Id="33" Count="0" />
      <LineId Id="18" Count="0" />
      <LineId Id="6" Count="0" />
      <LineId Id="8" Count="1" />
      <LineId Id="37" Count="0" />
      <LineId Id="35" Count="0" />
      <LineId Id="34" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkDefinition.saveMark">
      <LineId Id="14" Count="0" />
      <LineId Id="34" Count="0" />
      <LineId Id="32" Count="0" />
      <LineId Id="31" Count="0" />
      <LineId Id="39" Count="0" />
      <LineId Id="45" Count="0" />
      <LineId Id="42" Count="0" />
      <LineId Id="44" Count="0" />
      <LineId Id="65" Count="2" />
      <LineId Id="74" Count="0" />
      <LineId Id="60" Count="0" />
      <LineId Id="69" Count="0" />
      <LineId Id="48" Count="0" />
      <LineId Id="51" Count="2" />
      <LineId Id="64" Count="0" />
      <LineId Id="54" Count="0" />
      <LineId Id="50" Count="0" />
      <LineId Id="40" Count="0" />
      <LineId Id="33" Count="0" />
      <LineId Id="13" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>