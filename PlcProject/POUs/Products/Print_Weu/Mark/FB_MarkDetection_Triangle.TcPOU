<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.11">
  <POU Name="FB_MarkDetection_Triangle" Id="{9a49eb65-c69c-4374-bbae-64640fc50cbd}" SpecialFunc="None">
    <Declaration><![CDATA[(*
  Detects Marks and generates StartTrigger based on one EL1252 timestamp input I/O.
  Additionally returns lateral offset (+/- in [m]) to center of detected marks.
  
  NOTE: 
    - a mark has always a rising and falling edge of the sensor (triangle)
    - a center position is the middle of the triangular mark
  
   MarkLength -->
   |--------
   |      /
   |    / -- center --
^  |  /
|  |
| MarkHeight
*)
FUNCTION_BLOCK FB_MarkDetection_Triangle EXTENDS T_NamedBase
VAR_INPUT
  (*EL1252*)
  bIKp_StartSensor          AT%I* : BOOL;            (*Sensor start trigger*)
  tIKp_TimeStampPos         AT%I* : T_DCTIME64;      (*TimeStamp Pos_Edge @EL1252*)
  tIKn_TimeStampNeg         AT%I* : T_DCTIME64;      (*TimeStamp Neg_Edge @EL1252*)

  // configuration
  bEnable                         : BOOL;            (*Enable start pos detection sensor*)
  fResolution                     : LREAL := 1;      (*current used print resolution (dpi*SubPx)*)
  fSubstrateLength                : LREAL;            (*length of substrate in [m]*)
  pMarkDefinition                 : POINTER TO ST_MarkDefinition_Triangle;  (*mark definition*)
  
  // states
  nCurrentPos                     : DINT;            (*current position in Pulses/Subpixels*)
  fCurrentSpeed                   : REAL;            (*actual speed of conveyor in [m/s]*)
END_VAR
VAR_OUTPUT
  bStartTrig                      : BOOL;       (*Start Trigger Edge*)
  nOffset_X0                      : DINT;       (*X0 Position [SubPx]*)
  fLateralOffset                  : LREAL;      (*Lateral +/- shift in Y [m]*)
  fSubstrateLengthDetected        : LREAL;      (*Length of detected substrate [m], =0 if unknown*)
  bAreaOk                         : BOOL;       (*mark was detected in ok area*)
END_VAR
VAR
  rfT_Enable                      : RF_TRIG;    // edge detection enable

  // sensor
  rfT_StartSensor                 : RF_TRIG;    // edge detection start trigger
  tRisingEdge, tFallingEdge       : T_DCTIME64; // detected edges
  bMarkStartDetected, bMarkEndDetected : BOOL;
  
  // inhibit
  bInhibSensor                    : BOOL;       (*inhibit sensor signals, TRUE=inhibit*)
  nInhibitSensorDistance          : DINT;       (*inhibit length in pulseto X0 [SubPx]*)
  bReleaseSensor                  : BOOL;       (*condition to send a stop trigger*)

  // X0 calculation based on timestamp    
  tCurrentTime                    : T_DCTIME64; (* Get Current Timestamp *)
  fL_CurrentTimeStamp             : LREAL;
  fI_Sensor_TimeStamp             : LREAL;
  fDeltaDistance                  : LREAL;      (*Distance that the substrate moved between the detection and the treatment of the information [m]*)
  iL_DeltaPosition                : DINT;
  nLastX0                         : DINT;       // last detected X0 for substrate length calculation
  
  // mark detection
  fMarkDuration                  : LREAL;
  fMarkLengthDetected            : LREAL;       (*[m]*)
END_VAR
VAR PERSISTENT
  nR_AreaMarkSensorOk             : INT := 10;  (*Area with the correct arrangement of the mark sensor [%]*)
END_VAR
VAR CONSTANT
  fInhibitSubstrateMargin         : REAL := 0.010;   (*decrease substrate for inhibit in [m]*)
  
  (*old compensation*)
  //nC_CurrentTimeStampComp         : DINT := 2_000;   (*µs*)
  //nC_SensorTimeStampComp          : DINT := 150;     (*µs*)
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[// check parameter
IF fResolution = 0 OR pMarkDefinition = 0 THEN RETURN; END_IF

rfT_Enable(CLK:=bEnable);                 // edge detection
rfT_StartSensor(CLK:=bIKp_StartSensor);   // edge detection
bStartTrig := FALSE;                      // reset (only a one cycle pulse)

// reset 
IF rfT_Enable.RT OR rfT_Enable.FT THEN reset(); END_IF;

IF NOT bEnable THEN RETURN; END_IF    // do nothing if not enabled



// -- sensor inhibition control
nInhibitSensorDistance := F_MeterToSubPixel(fPosMeter:=fSubstrateLength - fInhibitSubstrateMargin, fResoSubPx:=fResolution);
bReleaseSensor := (nCurrentPos >= (nOffset_X0 + nInhibitSensorDistance));
IF bReleaseSensor THEN    // sheet end reached
  bInhibSensor  := FALSE;
  bMarkStartDetected := bMarkEndDetected := FALSE; 
END_IF;


// -- rising edge detection
IF rfT_StartSensor.RT AND NOT bInhibSensor THEN
  tRisingEdge := tIKp_TimeStampPos;
  bMarkStartDetected := TRUE;
  
 // before calculation with some compensation
(*
  // Calculate the original position in our position domain
  tCurrentTime  := F_GetCurDcTaskTime64();
  fL_CurrentTimeStamp  := (ULINT_TO_LREAL(tCurrentTime) - (nC_CurrentTimeStampComp * 1_000)) / 1_000_000.0; (*in ms*)
  fI_Sensor_TimeStamp := (ULINT_TO_LREAL(tRisingEdge) - (nC_SensorTimeStampComp  * 1_000)) / 1_000_000.0; (*in ms*)

  // Treatment of the information
  fDeltaDistance := (fL_CurrentTimeStamp - fI_Sensor_TimeStamp) * 0.001 * fCurrentSpeed;	(* Distance in pulses that the substrate has traveled between the sensor detection and the PLC treatment *)
  iL_DeltaPosition := FC_LREAL_TO_DINT(fDeltaDistance * (1 / (0.0254 / fI_Resolution)));  (*1/1px*)	(* Travel of the substrate between the time of acquisition and the time of treatment *)
  nOffset_X0       := nCurrentPos - iL_DeltaPosition;	(* Position where the sheet has been detected *)
*)

  // like DMAX
  (*Distance in [m] that the substrate has traveled between the sensor detection (time) current plc cycle*)
  tCurrentTime := F_GetCurDcTaskTime64();                      // current dc time (most accurate time stamp we have)  
  fDeltaDistance := UINT64_TO_LREAL(UInt64Sub64(ULINT_TO_ULARGE(tCurrentTime), ULINT_TO_ULARGE(tRisingEdge))) * 1E-9 * fCurrentSpeed;
  nOffset_X0 := nCurrentPos - F_MeterToSubPixel(fPosMeter:=fDeltaDistance, fResoSubPx:=fResolution);    (*Position where the sheet has been detected in [SubPx]*)

END_IF;


// -- falling edge detection
IF rfT_StartSensor.FT AND NOT bInhibSensor THEN
  tFallingEdge := tIKn_TimeStampNeg;
  bMarkEndDetected := TRUE;

  fMarkDuration    := LREAL_TO_REAL(ULINT_TO_LREAL(tFallingEdge) - ULINT_TO_LREAL(tRisingEdge));		(* Calculate how long the signal was ON *)
  fMarkLengthDetected := fMarkDuration * fCurrentSpeed * 0.000_000_001;			(* Calculate the equivalence*)
  bInhibSensor      := TRUE;
  
  // ==>  validate trigger
  IF NOT bMarkStartDetected THEN 
    LogError('Missing rigsing trigger edge, ignore trigger'); 
  ELSE
    bAreaOk := analizeMark();   // calculate lateral offset
    fSubstrateLengthDetected := calcSubstrateLength();
    bStartTrig := TRUE;     // generate a trigger (X0 is set)
  END_IF
  
END_IF;

]]></ST>
    </Implementation>
    <Method Name="analizeMark" Id="{8364dcc7-df22-49f7-92e3-a9e0b842c7bc}">
      <Declaration><![CDATA[(*
  Check if mark was detected in ok area.
  :returns:  TRUE if in OK area
*)
METHOD PRIVATE analizeMark : BOOL]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF pMarkDefinition^.fHeight = 0 OR pMarkDefinition^.fLength = 0 THEN fLateralOffset := 0; bInArea:=TRUE; RETURN; END_IF


(*Sensor should aligned to the middle of the sensor (fI_MarkHeight / 2). *)
(*With the difference of the measured lenght to the normal lenght, the fO_LateralOffset can be calculated*)
(* invert in case of wrong mirrored marks *)
IF pMarkDefinition^.bInvertedX THEN
  fLateralOffset := -1*((fMarkLengthDetected * (pMarkDefinition^.fHeight / 2 ) / (pMarkDefinition^.fLength / 2)) - (pMarkDefinition^.fHeight / 2 ));
ELSE     
  fLateralOffset := (fMarkLengthDetected * (pMarkDefinition^.fHeight / 2 ) / (pMarkDefinition^.fLength / 2)) - (pMarkDefinition^.fHeight / 2 );
END_IF

// check position qualitiy
analizeMark := FC_COMPARE_RANGE_PERCENT(   fI_ValueSet := (pMarkDefinition^.fHeight / 2)
                                     , fI_ValueActual  := (pMarkDefinition^.fHeight / 2) + fLateralOffset
                                     , fI_RangePercent := nR_AreaMarkSensorOk);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="calcSubstrateLength" Id="{663931c2-87f9-47bb-82a0-83f37d5ad41a}">
      <Declaration><![CDATA[METHOD PRIVATE calcSubstrateLength
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// -- substrate length calcualtion
IF nLastX0 <> 0 THEN
  calcSubstrateLength := F_SubPixelToMeter(lPosSubPx:=ABS(nOffset_X0-nLastX0), fResSubPx:=fResolution);  
ELSE
  calcSubstrateLength := 0;
END_IF

nLastX0 := nOffset_X0;  // save current]]></ST>
      </Implementation>
    </Method>
    <Method Name="reset" Id="{f531218a-4841-479d-b5e0-1334f8015385}">
      <Declaration><![CDATA[METHOD reset
]]></Declaration>
      <Implementation>
        <ST><![CDATA[bInhibSensor := FALSE;
bMarkStartDetected:=bMarkEndDetected := FALSE; 
nLastX0 := 0;
fLateralOffset := 0;
fSubstrateLengthDetected := 0;]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="FB_MarkDetection_Triangle">
      <LineId Id="6809" Count="63" />
      <LineId Id="6887" Count="0" />
      <LineId Id="6873" Count="4" />
      <LineId Id="6884" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkDetection_Triangle.analizeMark">
      <LineId Id="13" Count="0" />
      <LineId Id="15" Count="0" />
      <LineId Id="14" Count="0" />
      <LineId Id="6" Count="6" />
      <LineId Id="5" Count="0" />
      <LineId Id="17" Count="1" />
      <LineId Id="20" Count="1" />
      <LineId Id="19" Count="0" />
      <LineId Id="16" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkDetection_Triangle.calcSubstrateLength">
      <LineId Id="7" Count="2" />
      <LineId Id="12" Count="1" />
      <LineId Id="5" Count="0" />
      <LineId Id="11" Count="0" />
      <LineId Id="10" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkDetection_Triangle.reset">
      <LineId Id="6" Count="0" />
      <LineId Id="11" Count="0" />
      <LineId Id="10" Count="0" />
      <LineId Id="8" Count="1" />
    </LineIds>
  </POU>
</TcPlcObject>